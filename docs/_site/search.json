[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CaML - Causal ML",
    "section": "",
    "text": "Causal Machine Learning",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "CaML - Causal ML",
    "section": "Welcome!",
    "text": "Welcome!\nCaML provides a high-level API for an opinionated framework in performing Causal ML to estimate Average Treatment Effects (ATEs), Group Average Treatment Effects (GATEs), and Conditional Average Treatment Effects (CATEs), and to provide mechanisms to utilize these models for out of sample validation, prediction, & policy prescription.\nThe codebase is comprised primarily of extensions & abstractions over top of EconML & DoubleML with techniques motivated heavily by Causal ML Book and additional research.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#background",
    "href": "index.html#background",
    "title": "CaML - Causal ML",
    "section": "Background",
    "text": "Background\nThe origins of CaML are rooted in a desire to develop a set of helper tools to abstract and streamline techniques & best pratices in Causal ML/Econometrics for estimating ATEs, GATEs, and CATEs, along with policy prescription. In addition, we seek to provide a framework for validating & scoring these models on out of sample data to help set the foundations for an AutoML framework for CATE models.\nAs we began working on these helper tools, we begun to see the value in reformulating this framework into a reusable package for wider use amongst the community and to provide an opinionated framework that can be integrated into productionalized systems, particularly experimentation platforms, for efficient estimation of causal parameters for reporting & decision-making purposes.\nAll of the standard assumptions for causal inference still apply in order for these tools & techniques to provide unbiased inference. A great resource for the CausalML landscape is the CausalML book written and publicly available generously by V. Chernozhukov, C. Hansen, N. Kallus, M. Spindler, & V. Syrgkanis.\nGiven a key motivation is to provide a tool for productionalized systems, we are building this package with interoperability and extensibility as core values. As of now, the tools utilized still rely on in-memory datasets for estimation (via EconML for causal models & flaml for AutoML of nuissance functions), but we leverage Ray & Spark for distributing certain processes where appropriate and if available for the user.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "04_Reference/index.html",
    "href": "04_Reference/index.html",
    "title": "API Reference",
    "section": "",
    "text": "from caml import *\n\n\n\nCamlCATE\nThe CamlCATE class represents an opinionated framework of Causal Machine Learning techniques for estimating highly accurate conditional average treatment effects (CATEs).\n\n\nFastOLS\nFastOLS is an optimized implementation of the OLS estimator designed specifically with treatment effect estimation in mind.\n\n\n\n\n\n\nfrom caml.extensions.synthetic_data import *\n\n\n\nCamlSyntheticDataGenerator\nGenerate highly flexible synthetic data for use in causal inference and CaML testing.\n\n\nmake_partially_linear_dataset_simple\nSimulate data generating process from a partially linear model with a simple 1 or 2 dimensional CATE function.\n\n\nmake_partially_linear_dataset_constant\nSimulate a data generating process from a partially linear model with a constant treatment effect (ATE only).\n\n\nmake_fully_heterogeneous_dataset\nSimulate data generating process from an interactive regression model with fully heterogenous treatment effects.\n\n\n\n\n\n\nfrom caml.extensions.plots import *\n\n\n\ncate_histogram_plot\nPlots a histogram the estimated CATEs.\n\n\ncate_line_plot\nPlots a line plot of the ordered estimated CATEs as a rolling mean with optional confidence intervals.\n\n\ncate_true_vs_estimated_plot\nPlots a scatter plot of the estimated CATEs against the true CATEs.\n\n\n\n\n\n\n\n\n\ngenerics.experimental\nDecorator to mark functions or classes as experimental.\n\n\ngenerics.timer\nDecorator to measure the execution time of a function or method, logged at DEBUG level.\n\n\ngenerics.maybe_jit\nDecorator to JIT compile a function using JAX, if available.\n\n\ngenerics.PandasConvertibleDataFrame\nProtocol for DataFrame-like objects that are either pandas dataframes or\n\n\nlogging.configure_logging\nConfigure logging for the entire application.\n\n\nlogging.set_log_level\nChange the logging level after initial configuration.",
    "crumbs": [
      "API Reference"
    ]
  },
  {
    "objectID": "04_Reference/index.html#caml-core",
    "href": "04_Reference/index.html#caml-core",
    "title": "API Reference",
    "section": "",
    "text": "from caml import *\n\n\n\nCamlCATE\nThe CamlCATE class represents an opinionated framework of Causal Machine Learning techniques for estimating highly accurate conditional average treatment effects (CATEs).\n\n\nFastOLS\nFastOLS is an optimized implementation of the OLS estimator designed specifically with treatment effect estimation in mind.",
    "crumbs": [
      "API Reference"
    ]
  },
  {
    "objectID": "04_Reference/index.html#traditional-estimators",
    "href": "04_Reference/index.html#traditional-estimators",
    "title": "API Reference",
    "section": "",
    "text": "from caml import *\n\n\n\nFastOLS\nFastOLS is a fast implementation of the OLS estimator designed specifically with treatment effect estimation in mind.",
    "crumbs": [
      "API Reference"
    ]
  },
  {
    "objectID": "04_Reference/index.html#synthetic-data-generation",
    "href": "04_Reference/index.html#synthetic-data-generation",
    "title": "API Reference",
    "section": "",
    "text": "from caml.extensions.synthetic_data import *\n\n\n\nCamlSyntheticDataGenerator\nGenerate highly flexible synthetic data for use in causal inference and CaML testing.\n\n\nmake_partially_linear_dataset_simple\nSimulate data generating process from a partially linear model with a simple 1 or 2 dimensional CATE function.\n\n\nmake_partially_linear_dataset_constant\nSimulate a data generating process from a partially linear model with a constant treatment effect (ATE only).\n\n\nmake_fully_heterogeneous_dataset\nSimulate data generating process from an interactive regression model with fully heterogenous treatment effects.",
    "crumbs": [
      "API Reference"
    ]
  },
  {
    "objectID": "04_Reference/index.html#plots",
    "href": "04_Reference/index.html#plots",
    "title": "API Reference",
    "section": "",
    "text": "from caml.extensions.plots import *\n\n\n\ncate_histogram_plot\nPlots a histogram the estimated CATEs.\n\n\ncate_line_plot\nPlots a line plot of the ordered estimated CATEs as a rolling mean with optional confidence intervals.\n\n\ncate_true_vs_estimated_plot\nPlots a scatter plot of the estimated CATEs against the true CATEs.",
    "crumbs": [
      "API Reference"
    ]
  },
  {
    "objectID": "04_Reference/index.html#developer-tools",
    "href": "04_Reference/index.html#developer-tools",
    "title": "API Reference",
    "section": "",
    "text": "generics.experimental\nDecorator to mark functions or classes as experimental.\n\n\ngenerics.timer\nDecorator to measure the execution time of a function or method, logged at DEBUG level.\n\n\ngenerics.maybe_jit\nDecorator to JIT compile a function using JAX, if available.\n\n\ngenerics.PandasConvertibleDataFrame\nProtocol for DataFrame-like objects that are either pandas dataframes or\n\n\nlogging.configure_logging\nConfigure logging for the entire application.\n\n\nlogging.set_log_level\nChange the logging level after initial configuration.",
    "crumbs": [
      "API Reference"
    ]
  },
  {
    "objectID": "04_Reference/CamlCATE.html",
    "href": "04_Reference/CamlCATE.html",
    "title": "CamlCATE",
    "section": "",
    "text": "CamlCATE(\n    self,\n    df,\n    Y,\n    T,\n    X,\n    W=None,\n    *,\n    discrete_treatment=True,\n    discrete_outcome=False,\n    seed=None,\n)\nThe CamlCATE class represents an opinionated framework of Causal Machine Learning techniques for estimating highly accurate conditional average treatment effects (CATEs).\nCamlCATE is experimental and may change significantly in future versions.\nThe CATE is defined formally as \\(\\mathbb{E}[\\tau|\\mathbf{X}]\\) where \\(\\tau\\) is the treatment effect and \\(\\mathbf{X}\\) is the set of covariates.\nThis class is built on top of the EconML library and provides a high-level API for fitting, validating, and making inference with CATE models, with best practices built directly into the API. The class is designed to be easy to use and understand, while still providing flexibility for advanced users. The class is designed to be used with pandas, polars, or pyspark backends, which ultimately get converted to NumPy Arrays under the hood to provide a level of extensibility & interoperability across different data processing frameworks.\nThe primary workflow for the CamlCATE class is as follows:\nFor technical details on conditional average treatment effects, see:\nNote: All the standard assumptions of Causal Inference apply to this class (e.g., exogeneity/unconfoundedness, overlap, positivity, etc.). The class does not check for these assumptions and assumes that the user has already thought through these assumptions before using the class.\nFor outcome/treatment support, see matrix."
  },
  {
    "objectID": "04_Reference/CamlCATE.html#parameters",
    "href": "04_Reference/CamlCATE.html#parameters",
    "title": "CamlCATE",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndf\npandas.DataFrame | polars.DataFrame | pyspark.sql.DataFrame\nThe input DataFrame representing the data for the CamlCATE instance.\nrequired\n\n\nY\nstr\nThe str representing the column name for the outcome variable.\nrequired\n\n\nT\nstr\nThe str representing the column name(s) for the treatment variable(s).\nrequired\n\n\nX\nstr | list[str]\nThe str (if unity) or list of feature names representing the feature set to be utilized for estimating heterogeneity/CATE.\nrequired\n\n\nW\nstr | list[str] | None\nThe str (if unity) or list of feature names representing the confounder/control feature set to be utilized only for nuisance function estimation. When W is passed, only Orthogonal learners will be leveraged.\nNone\n\n\ndiscrete_treatment\nbool\nA boolean indicating whether the treatment is discrete/categorical or continuous.\nTrue\n\n\ndiscrete_outcome\nbool\nA boolean indicating whether the outcome is binary or continuous.\nFalse\n\n\nseed\nint | None\nThe seed to use for the random number generator.\nNone"
  },
  {
    "objectID": "04_Reference/CamlCATE.html#attributes",
    "href": "04_Reference/CamlCATE.html#attributes",
    "title": "CamlCATE",
    "section": "Attributes",
    "text": "Attributes\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ndf\npandas.DataFrame | polars.DataFrame | pyspark.sql.DataFrame\nThe input DataFrame representing the data for the CamlCATE instance.\n\n\nY\nstr\nThe str representing the column name for the outcome variable.\n\n\nT\nstr\nThe str representing the column name(s) for the treatment variable(s).\n\n\nX\nIterable[str]\nThe str (if unity) or list of variable names representing the confounder/control feature set to be utilized for estimating heterogeneity/CATE and nuisance function estimation where applicable.\n\n\nW\nIterable[str] | None\nThe str (if unity) or list of variable names representing the confounder/control feature set to be utilized only for nuisance function estimation, where applicable. These will be included by default in Meta-Learners.\n\n\ndiscrete_treatment\nbool\nA boolean indicating whether the treatment is discrete/categorical or continuous.\n\n\ndiscrete_outcome\nbool\nA boolean indicating whether the outcome is binary or continuous.\n\n\navailable_estimators\nstr\nA list of the available CATE estimators out of the box. Validity of estimator at runtime will depend on the outcome and treatment types and be automatically selected.\n\n\nmodel_Y_X_W\nsklearn.base.BaseEstimator\nThe fitted nuisance function for the outcome variable.\n\n\nmodel_Y_X_W_T\nsklearn.base.BaseEstimator\nThe fitted nuisance function for the outcome variable with treatment variable.\n\n\nmodel_T_X_W\nsklearn.base.BaseEstimator\nThe fitted nuisance function for the treatment variable.\n\n\ncate_estimators\ndict[str, econml._cate_estimator.BaseCateEstimator | econml.score.EnsembleCateEstimator]\nDictionary of fitted cate estimator objects.\n\n\nvalidation_estimator\neconml._cate_estimator.BaseCateEstimator | econml.score.EnsembleCateEstimator\nThe fitted EconML estimator object for validation.\n\n\nvalidator_results\neconml.validate.results.EvaluationResults\nThe validation results object.\n\n\nfinal_estimator\neconml._cate_estimator.BaseCateEstimator | econml.score.EnsembleCateEstimator\nThe fitted EconML estimator object on the entire dataset after validation.\n\n\ninput_names\ndict[str, list[str]]\nThe feature, outcome, and treatment names used in the CATE estimators."
  },
  {
    "objectID": "04_Reference/CamlCATE.html#examples",
    "href": "04_Reference/CamlCATE.html#examples",
    "title": "CamlCATE",
    "section": "Examples",
    "text": "Examples\n\nfrom caml import CamlCATE\nfrom caml.extensions.synthetic_data import CamlSyntheticDataGenerator\n\ndata_generator = CamlSyntheticDataGenerator(seed=10)\ndf = data_generator.df\n\ncaml_obj = CamlCATE(\n    df = df,\n    Y=\"Y1_continuous\",\n    T=\"T1_binary\",\n    X=[c for c in df.columns if \"X\" in c or \"W\" in c],\n    discrete_treatment=True,\n    discrete_outcome=False,\n    seed=0,\n)\n\nprint(caml_obj)\n\n================== CamlCATE Object ==================\nData Backend: pandas\nNo. of Observations: 10,000\nOutcome Variable: Y1_continuous\nDiscrete Outcome: False\nTreatment Variable: T1_binary\nDiscrete Treatment: True\nFeatures/Confounders for Heterogeneity (X): ['W1_continuous', 'W2_continuous', 'X1_continuous', 'X2_continuous']\nFeatures/Confounders as Controls (W): []\nRandom Seed: 0"
  },
  {
    "objectID": "04_Reference/CamlCATE.html#methods",
    "href": "04_Reference/CamlCATE.html#methods",
    "title": "CamlCATE",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nauto_nuisance_functions\nLeverages AutoML to find optimal nuisance functions/regression & propensity models for use in EconML CATE estimators.\n\n\nfit_validator\nFits the CATE models on the training set and evaluates them & ensembles based on the validation set.\n\n\nvalidate\nValidates the fitted CATE models on the test set to check for generalization performance.\n\n\nfit_final\nFits the final estimator on the entire dataset, after validation and testing.\n\n\npredict\nPredicts the CATE based on the fitted final estimator for either the internal dataset or provided Data.\n\n\nsummarize\nProvides population summary statistics for the CATE predictions for either the internal results or provided results.\n\n\n\n\nauto_nuisance_functions\nCamlCATE.auto_nuisance_functions(\n    flaml_Y_kwargs=None,\n    flaml_T_kwargs=None,\n    use_ray=False,\n    use_spark=False,\n)\nLeverages AutoML to find optimal nuisance functions/regression & propensity models for use in EconML CATE estimators.\nSets the model_Y_X_W, model_Y_X_W_T, and model_T_X_W attributes to the fitted nuisance functions.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nflaml_Y_kwargs\ndict | None\nThe keyword arguments for the FLAML AutoML search for the outcome model. Default implies the base parameters in CamlBase.\nNone\n\n\nflaml_T_kwargs\ndict | None\nThe keyword arguments for the FLAML AutoML search for the treatment model. Default implies the base parameters in CamlBase.\nNone\n\n\nuse_ray\nbool\nA boolean indicating whether to use Ray for parallel processing.\nFalse\n\n\nuse_spark\nbool\nA boolean indicating whether to use Spark for parallel processing.\nFalse\n\n\n\n\n\nExamples\n\nflaml_Y_kwargs = {\n    \"n_jobs\": -1,\n    \"time_budget\": 10,\n    \"verbose\": 0\n}\n\nflaml_T_kwargs = {\n    \"n_jobs\": -1,\n    \"time_budget\": 10,\n    \"verbose\": 0\n}\n\ncaml_obj.auto_nuisance_functions(\n    flaml_Y_kwargs=flaml_Y_kwargs,\n    flaml_T_kwargs=flaml_T_kwargs,\n    use_ray=False,\n    use_spark=False,\n)\n\nprint(caml_obj.model_Y_X_W)\nprint(caml_obj.model_Y_X_W_T)\nprint(caml_obj.model_T_X_W)\n\nRandomForestRegressor(max_features=0.7836065030168594, max_leaf_nodes=59,\n                      n_estimators=195, n_jobs=-1, random_state=12032022)\nRandomForestRegressor(max_features=0.7836065030168594, max_leaf_nodes=59,\n                      n_estimators=195, n_jobs=-1, random_state=12032022)\nLGBMClassifier(colsample_bytree=0.7493939654565648,\n               learning_rate=0.1810578513473099, max_bin=511,\n               min_child_samples=11, n_estimators=28, n_jobs=-1, num_leaves=4,\n               reg_alpha=0.0009765625, reg_lambda=8.009401600420933,\n               verbose=-1)\n\n\n\n\n\nfit_validator\nCamlCATE.fit_validator(\n    cate_estimators=['LinearDML', 'CausalForestDML', 'NonParamDML', 'SparseLinearDML-2D', 'DRLearner', 'ForestDRLearner', 'LinearDRLearner', 'DomainAdaptationLearner', 'SLearner', 'TLearner', 'XLearner'],\n    additional_cate_estimators=[],\n    ensemble=False,\n    rscorer_kwargs={},\n    use_ray=False,\n    ray_remote_func_options_kwargs={},\n    validation_size=0.2,\n    test_size=0.2,\n    sample_size=1.0,\n    n_jobs=-1,\n)\nFits the CATE models on the training set and evaluates them & ensembles based on the validation set.\nSets the validation_estimator attribute to the best fitted EconML estimator and cate_estimators attribute to all the fitted CATE models.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncate_estimators\nIterable[str]\nThe list of CATE estimators to fit and ensemble. Default implies all available models as defined by class.\n['LinearDML', 'CausalForestDML', 'NonParamDML', 'SparseLinearDML-2D', 'DRLearner', 'ForestDRLearner', 'LinearDRLearner', 'DomainAdaptationLearner', 'SLearner', 'TLearner', 'XLearner']\n\n\nadditional_cate_estimators\nlist[tuple[str, BaseCateEstimator]]\nThe list of additional CATE estimators to fit and ensemble\n[]\n\n\nensemble\nbool\nThe boolean indicating whether to ensemble the CATE models & score.\nFalse\n\n\nrscorer_kwargs\ndict\nThe keyword arguments for the econml.score.RScorer object.\n{}\n\n\nuse_ray\nbool\nA boolean indicating whether to use Ray for parallel processing.\nFalse\n\n\nray_remote_func_options_kwargs\ndict\nThe keyword arguments for the Ray remote function options.\n{}\n\n\nvalidation_size\nfloat\nThe fraction of the dataset to use for model scoring via RScorer.\n0.2\n\n\ntest_size\nfloat\nThe fraction of the dataset to hold out for final evaluation in the validate() method.\n0.2\n\n\nsample_size\nfloat\nThe fraction of the datasets to use. Useful for quick testing when dataframe is large. Defaults implies full training data.\n1.0\n\n\nn_jobs\nint\nThe number of parallel jobs to run.\n-1\n\n\n\n\n\nExamples\n\nfrom econml.dr import LinearDRLearner\n\nrscorer_kwargs = {\n    \"cv\": 3,\n    \"mc_iters\": 3,\n}\ncate_estimators = [\"LinearDML\", \"NonParamDML\", \"CausalForestDML\"]\nadditional_cate_estimators = [\n    (\n        \"LinearDRLearner\",\n        LinearDRLearner(\n            model_propensity=caml_obj.model_T_X_W,\n            model_regression=caml_obj.model_Y_X_W_T,\n            discrete_outcome=caml_obj.discrete_outcome,\n            cv=3,\n            random_state=0,\n        ),\n    )\n]\n\ncaml_obj.fit_validator(\n    cate_estimators=cate_estimators,\n    additional_cate_estimators=additional_cate_estimators,\n    rscorer_kwargs=rscorer_kwargs,\n    validation_size=0.2,\n    test_size=0.2\n)\n\nprint(caml_obj.validation_estimator)\nprint(caml_obj.cate_estimators)\n\n&lt;econml.dml.dml.NonParamDML object at 0x7cde45848a30&gt;\n[('LinearDML', &lt;econml.dml.dml.LinearDML object at 0x7cdf49ac1db0&gt;), ('NonParamDML', &lt;econml.dml.dml.NonParamDML object at 0x7cdf49ac23b0&gt;), ('CausalForestDML', &lt;econml.dml.causal_forest.CausalForestDML object at 0x7cdf49ac24a0&gt;), ('LinearDRLearner', &lt;econml.dr._drlearner.LinearDRLearner object at 0x7cdf49ac2500&gt;)]\n\n\n\n\n\nvalidate\nCamlCATE.validate(\n    n_groups=4,\n    n_bootstrap=100,\n    estimator=None,\n    print_full_report=True,\n)\nValidates the fitted CATE models on the test set to check for generalization performance.\nUses the DRTester class from EconML to obtain the Best Linear Predictor (BLP), Calibration, AUTOC, and QINI. See EconML documentation for more details. In short, we are checking for the ability of the model to find statistically significant heterogeneity in a “well-calibrated” fashion.\nSets the validator_report attribute to the validation report.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn_groups\nint\nThe number of quantile based groups used to calculate calibration scores.\n4\n\n\nn_bootstrap\nint\nThe number of boostrap samples to run when calculating confidence bands.\n100\n\n\nestimator\nBaseCateEstimator | EnsembleCateEstimator | None\nThe estimator to validate. Default implies the best estimator from the validation set.\nNone\n\n\nprint_full_report\nbool\nA boolean indicating whether to print the full validation report.\nTrue\n\n\n\n\n\nExamples\n\ncaml_obj.validate()\n\ncaml_obj.validator_results\n\n   treatment  blp_est  blp_se  blp_pval  qini_est  qini_se  qini_pval  autoc_est  autoc_se  autoc_pval  cal_r_squared\n0          1    0.929   0.012       0.0     2.522    0.058        0.0      6.718     0.186         0.0          0.958\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfit_final\nCamlCATE.fit_final()\nFits the final estimator on the entire dataset, after validation and testing.\nSets the input_names and final_estimator class attributes.\n\nExamples\n\ncaml_obj.fit_final()\n\nprint(caml_obj.final_estimator)\nprint(caml_obj.input_names)\n\n&lt;econml.dml.dml.NonParamDML object at 0x7cdf49ac2980&gt;\n{'feature_names': ['W1_continuous', 'W2_continuous', 'X1_continuous', 'X2_continuous'], 'output_names': 'Y1_continuous', 'treatment_names': 'T1_binary'}\n\n\n\n\n\npredict\nCamlCATE.predict(X=None, T0=0, T1=1, T=None)\nPredicts the CATE based on the fitted final estimator for either the internal dataset or provided Data.\nFor binary treatments, the CATE is the estimated effect of the treatment and for a continuous treatment, the CATE is the estimated effect of a one-unit increase in the treatment. This can be modified by setting the T0 and T1 parameters to the desired treatment levels.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nX\npandas.DataFrame | np.ndarray | None\nThe DataFrame containing the features (X) for which CATE needs to be predicted. If not provided, defaults to the internal dataset.\nNone\n\n\nT0\nint\nBase treatment for each sample.\n0\n\n\nT1\nint\nTarget treatment for each sample.\n1\n\n\nT\npandas.DataFrame | np.ndarray | None\nTreatment vector if continuous treatment is leveraged for computing marginal effects around treatments for each individual.\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nThe predicted CATE values if return_predictions is set to True.\n\n\n\n\n\nExamples\n\ncaml_obj.predict()\n\narray([ -3.00423661,  12.62121768, -10.49356703, ...,   8.75449543,\n         7.58298216,  -2.75134847])\n\n\n\n\n\nsummarize\nCamlCATE.summarize(cate_predictions=None)\nProvides population summary statistics for the CATE predictions for either the internal results or provided results.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncate_predictions\nnp.ndarray | None\nThe CATE predictions for which summary statistics will be generated. If not provided, defaults to internal CATE predictions generated by predict() method with X=None.\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npandas.DataFrame | pandas.Series\nThe summary statistics for the CATE predictions.\n\n\n\n\n\nExamples\n\ncaml_obj.summarize()\n\n\n\n\n\n\n\n\ncate_predictions_0_1\n\n\n\n\ncount\n10000.000000\n\n\nmean\n3.538010\n\n\nstd\n9.687032\n\n\nmin\n-102.633620\n\n\n25%\n-3.995593\n\n\n50%\n3.945685\n\n\n75%\n11.317650\n\n\nmax\n21.709791"
  },
  {
    "objectID": "04_Reference/cate_histogram_plot.html",
    "href": "04_Reference/cate_histogram_plot.html",
    "title": "cate_histogram_plot",
    "section": "",
    "text": "cate_histogram_plot(\n    estimated_cates,\n    *,\n    true_cates=None,\n    figure_kwargs={},\n    hist_kwargs={},\n)\nPlots a histogram the estimated CATEs."
  },
  {
    "objectID": "04_Reference/cate_histogram_plot.html#parameters",
    "href": "04_Reference/cate_histogram_plot.html#parameters",
    "title": "cate_histogram_plot",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nestimated_cates\nArrayLike\nThe estimated CATEs.\nrequired\n\n\ntrue_cates\nArrayLike | None\nThe true CATEs.\nNone\n\n\nfigure_kwargs\ndict\nMatplotlib figure arguments.\n{}\n\n\nhist_kwargs\ndict\nMatplotlib hist arguments.\n{}"
  },
  {
    "objectID": "04_Reference/cate_histogram_plot.html#returns",
    "href": "04_Reference/cate_histogram_plot.html#returns",
    "title": "cate_histogram_plot",
    "section": "Returns",
    "text": "Returns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nmatplotlib.pyplot.Figure\nThe histogram figure object."
  },
  {
    "objectID": "04_Reference/cate_histogram_plot.html#examples",
    "href": "04_Reference/cate_histogram_plot.html#examples",
    "title": "cate_histogram_plot",
    "section": "Examples",
    "text": "Examples\n\nimport numpy as np\nfrom caml.extensions.plots import cate_histogram_plot\n\nnp.random.seed(42)\ntrue_cates = np.random.normal(0, 1, 1000)\nestimated_cates = true_cates + np.random.normal(0, 0.5, 1000)\n\nfig = cate_histogram_plot(estimated_cates, true_cates=true_cates, hist_kwargs={'bins': 25})\nfig"
  },
  {
    "objectID": "04_Reference/utils.cls_typechecked.html",
    "href": "04_Reference/utils.cls_typechecked.html",
    "title": "utils.cls_typechecked",
    "section": "",
    "text": "utils.cls_typechecked(cls)\nClass decorator to typecheck all methods of a class.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\n\nThe class to decorate.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ncls: The decorated class."
  },
  {
    "objectID": "04_Reference/utils.cls_typechecked.html#parameters",
    "href": "04_Reference/utils.cls_typechecked.html#parameters",
    "title": "utils.cls_typechecked",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ncls\n\nThe class to decorate.\nrequired"
  },
  {
    "objectID": "04_Reference/utils.cls_typechecked.html#returns",
    "href": "04_Reference/utils.cls_typechecked.html#returns",
    "title": "utils.cls_typechecked",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\ncls: The decorated class."
  },
  {
    "objectID": "04_Reference/logging.set_log_level.html",
    "href": "04_Reference/logging.set_log_level.html",
    "title": "logging.set_log_level",
    "section": "",
    "text": "logging.set_log_level(level)\nChange the logging level after initial configuration.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlevel\nint\nThe new logging level to use.\nrequired"
  },
  {
    "objectID": "04_Reference/logging.set_log_level.html#parameters",
    "href": "04_Reference/logging.set_log_level.html#parameters",
    "title": "logging.set_log_level",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nlevel\nint\nThe new logging level to use.\nrequired"
  },
  {
    "objectID": "04_Reference/generics.generate_random_string.html",
    "href": "04_Reference/generics.generate_random_string.html",
    "title": "generics.generate_random_string",
    "section": "",
    "text": "generics.generate_random_string(N)\nFunction to generate a random string of ascii lowercase letters and digits of length N.\nUtilized to generate a random table name for the Ibis Tables.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN\nint\nThe length of random string to generate.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nThe random string of length N."
  },
  {
    "objectID": "04_Reference/generics.generate_random_string.html#parameters",
    "href": "04_Reference/generics.generate_random_string.html#parameters",
    "title": "generics.generate_random_string",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nN\nint\nThe length of random string to generate.\nrequired"
  },
  {
    "objectID": "04_Reference/generics.generate_random_string.html#returns",
    "href": "04_Reference/generics.generate_random_string.html#returns",
    "title": "generics.generate_random_string",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nstr\nThe random string of length N."
  },
  {
    "objectID": "04_Reference/generics.timer.html",
    "href": "04_Reference/generics.timer.html",
    "title": "generics.timer",
    "section": "",
    "text": "generics.timer(operation_name=None)\nDecorator to measure the execution time of a function or method, logged at DEBUG level.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noperation_name\n\nThe name of the operation to be timed. If None, the name of the function or method will be used.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncallable\nThe decorated function or method"
  },
  {
    "objectID": "04_Reference/generics.timer.html#parameters",
    "href": "04_Reference/generics.timer.html#parameters",
    "title": "generics.timer",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\noperation_name\n\nThe name of the operation to be timed. If None, the name of the function or method will be used.\nNone"
  },
  {
    "objectID": "04_Reference/generics.timer.html#returns",
    "href": "04_Reference/generics.timer.html#returns",
    "title": "generics.timer",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\ncallable\nThe decorated function or method"
  },
  {
    "objectID": "04_Reference/utils.generate_random_string.html",
    "href": "04_Reference/utils.generate_random_string.html",
    "title": "utils.generate_random_string",
    "section": "",
    "text": "utils.generate_random_string(N)\nFunction to generate a random string of ascii lowercase letters and digits of length N.\nUtilized to generate a random table name for the Ibis Tables.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN\nint\nThe length of random string to generate.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nstr: The random string of length N."
  },
  {
    "objectID": "04_Reference/utils.generate_random_string.html#parameters",
    "href": "04_Reference/utils.generate_random_string.html#parameters",
    "title": "utils.generate_random_string",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nN\nint\nThe length of random string to generate.\nrequired"
  },
  {
    "objectID": "04_Reference/utils.generate_random_string.html#returns",
    "href": "04_Reference/utils.generate_random_string.html#returns",
    "title": "utils.generate_random_string",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nstr: The random string of length N."
  },
  {
    "objectID": "04_Reference/CamlSyntheticDataGenerator.html",
    "href": "04_Reference/CamlSyntheticDataGenerator.html",
    "title": "CamlSyntheticDataGenerator",
    "section": "",
    "text": "CamlSyntheticDataGenerator(\n    self,\n    n_obs=10000,\n    n_cont_outcomes=1,\n    n_binary_outcomes=0,\n    n_cont_treatments=0,\n    n_binary_treatments=1,\n    n_discrete_treatments=0,\n    n_cont_confounders=2,\n    n_binary_confounders=0,\n    n_discrete_confounders=0,\n    n_cont_modifiers=2,\n    n_binary_modifiers=0,\n    n_discrete_modifiers=0,\n    n_confounding_modifiers=0,\n    stddev_outcome_noise=1.0,\n    stddev_treatment_noise=1.0,\n    causal_model_functional_form='linear',\n    n_nonlinear_transformations=None,\n    n_nonlinear_interactions=None,\n    seed=None,\n)\nGenerate highly flexible synthetic data for use in causal inference and CaML testing.\nCamlSyntheticDataGenerator is experimental and may change significantly in future versions.\nThe general form of the data generating process is:\n\\[\n\\mathbf{Y_i} = \\tau (\\mathbf{X_i}) \\mathbf{T_i} + g(\\mathbf{W_i}, \\mathbf{X_i}) + \\mathbf{\\epsilon_i}\n\\] \\[\n\\mathbf{T}_i=f(\\mathbf{W}_i, \\mathbf{X_{i,\\mathcal{S}}})+\\mathbf{\\eta_i}\n\\]\nwhere \\(\\mathbf{Y_i}\\) are the outcome(s), \\(\\mathbf{T_i}\\) are the treatment(s), \\(\\mathbf{X_i}\\) are the effect modifiers (leveraged for treatment effect heterogeneity) with an optional random subset \\(\\mathcal{S}\\) selected as confounders, \\(\\mathbf{W_i}\\) are the confounders, \\(\\mathbf{\\epsilon_i}\\) and \\(\\mathbf{\\eta_i}\\) are the error terms drawn from normal distributions with optional specified standard deviation, \\(\\tau\\) is the CATE function, \\(g\\) is the linearly seperable/nuisance component of the outcome function, and \\(f\\) is the treatment function. Note in the case of no modifier variables, we obtain a purely partially linear model, with \\(\\tau\\) as a constant.\nFor linear data generating process, \\(f\\) and \\(g\\) consist of strictly linear terms and untransformed variables. \\(\\tau\\) consists linear interaction terms.\nFor nonlinear data generating process, \\(f\\) and \\(g\\) are generated via Generalized Additive Models (GAMs) with randomly selected transformations and interaction terms controlled via n_nonlinear_transformations. \\(\\tau\\) contains interaction terms with transformed modifiers controlled via n_nonlinear_interactions.\nAs a DAG, the data generating process can be roughly represented as:"
  },
  {
    "objectID": "04_Reference/CamlSyntheticDataGenerator.html#parameters",
    "href": "04_Reference/CamlSyntheticDataGenerator.html#parameters",
    "title": "CamlSyntheticDataGenerator",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn_obs\nint\nNumber of observations.\n10000\n\n\nn_cont_outcomes\nint\nNumber of continuous outcomes (\\(Y\\)).\n1\n\n\nn_binary_outcomes\nint\nNumber of binary outcomes (\\(Y\\)).\n0\n\n\nn_cont_treatments\nint\nNumber of continuous treatments (\\(T\\)).\n0\n\n\nn_binary_treatments\nint\nNumber of binary treatments (\\(T\\)).\n1\n\n\nn_discrete_treatments\nint\nNumber of discrete treatments (\\(T\\)).\n0\n\n\nn_cont_confounders\nint\nNumber of continuous confounders (\\(W\\)).\n2\n\n\nn_binary_confounders\nint\nNumber of binary confounders (\\(W\\)).\n0\n\n\nn_discrete_confounders\nint\nNumber of discrete confounders (\\(W\\)).\n0\n\n\nn_cont_modifiers\nint\nNumber of continuous treatment effect modifiers (\\(X\\)).\n2\n\n\nn_binary_modifiers\nint\nNumber of binary treatment effect modifiers (\\(X\\)).\n0\n\n\nn_discrete_modifiers\nint\nNumber of discrete treatment effect modifiers (\\(X\\)).\n0\n\n\nn_confounding_modifiers\nint\nNumber of confounding treatment effect modifiers (\\(X_{\\mathcal{S}}\\)).\n0\n\n\nstddev_outcome_noise\nfloat\nStandard deviation of the outcome noise (\\(\\epsilon\\)).\n1.0\n\n\nstddev_treatment_noise\nfloat\nStandard deviation of the treatment noise (\\(\\eta\\)).\n1.0\n\n\ncausal_model_functional_form\nstr\nFunctional form of the causal model, can be “linear” or “nonlinear”.\n'linear'\n\n\nn_nonlinear_transformations\nint | None\nNumber of nonlinear transformations, only applies if causal_model_functional_form=“nonlinear”.\nNone\n\n\nn_nonlinear_interactions\nint | None\nNumber of nonlinear interactions with treatment, introducing heterogeneity, only applies if causal_model_functional_form=“nonlinear”.\nNone\n\n\nseed\nint | None\nRandom seed to use for generating the data.\nNone"
  },
  {
    "objectID": "04_Reference/CamlSyntheticDataGenerator.html#attributes",
    "href": "04_Reference/CamlSyntheticDataGenerator.html#attributes",
    "title": "CamlSyntheticDataGenerator",
    "section": "Attributes",
    "text": "Attributes\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ndf\npandas.DataFrame\nThe data generated by the data generation process.\n\n\ncates\npandas.DataFrame\nThe true conditional average treatment effects (CATEs) of the data.\n\n\nates\npandas.DataFrame\nThe true average treatment effects (ATEs) of the data.\n\n\ndgp\ndict[str, pandas.DataFrame]\nThe true data generating processes of the treatments and outcomes."
  },
  {
    "objectID": "04_Reference/CamlSyntheticDataGenerator.html#examples",
    "href": "04_Reference/CamlSyntheticDataGenerator.html#examples",
    "title": "CamlSyntheticDataGenerator",
    "section": "Examples",
    "text": "Examples\n\nfrom caml.extensions.synthetic_data import CamlSyntheticDataGenerator\n\ndata_generator = CamlSyntheticDataGenerator(seed=10)\ndata_generator.df\n\n\n\n\n\n\n\n\nW1_continuous\nW2_continuous\nX1_continuous\nX2_continuous\nT1_binary\nY1_continuous\n\n\n\n\n0\n0.354380\n-3.252276\n2.715662\n-3.578800\n1\n-11.068941\n\n\n1\n0.568499\n2.484069\n-6.402235\n-2.611815\n0\n4.742376\n\n\n2\n0.162715\n8.842902\n1.288770\n-3.788545\n0\n23.149713\n\n\n3\n0.362944\n-0.959538\n1.080988\n-3.542550\n0\n-3.390266\n\n\n4\n0.612101\n1.417536\n4.143630\n-4.112453\n1\n-0.990706\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n9995\n0.340436\n0.241095\n-6.524222\n-3.188783\n0\n-3.946413\n\n\n9996\n0.019523\n1.338152\n-2.555492\n-3.643733\n0\n3.952691\n\n\n9997\n0.325401\n1.258659\n-3.340546\n-4.255203\n1\n10.588338\n\n\n9998\n0.586715\n1.263264\n-2.826709\n-4.149383\n1\n9.652253\n\n\n9999\n0.003002\n6.723381\n1.260782\n-3.660600\n0\n19.840431\n\n\n\n\n10000 rows × 6 columns\n\n\n\n\ndata_generator.cates\n\n\n\n\n\n\n\n\nCATE_of_T1_binary_on_Y1_continuous\n\n\n\n\n0\n-2.908078\n\n\n1\n13.601348\n\n\n2\n-0.003848\n\n\n3\n0.173513\n\n\n4\n-5.154262\n\n\n...\n...\n\n\n9995\n14.346026\n\n\n9996\n7.190235\n\n\n9997\n9.228579\n\n\n9998\n8.155846\n\n\n9999\n-0.064142\n\n\n\n\n10000 rows × 1 columns\n\n\n\n\ndata_generator.ates\n\n\n\n\n\n\n\n\nTreatment\nATE\n\n\n\n\n0\nT1_binary_on_Y1_continuous\n3.912029\n\n\n\n\n\n\n\n\nfor t, df in data_generator.dgp.items():\n    print(f\"\\nDGP for {t}:\")\n    print(df)\n\n\nDGP for T1_binary:\n      covariates    params global_transformation\n0  W1_continuous  1.281740               Sigmoid\n1  W2_continuous -0.575915               Sigmoid\n\nDGP for Y1_continuous:\n                    covariates    params global_transformation\n0                W1_continuous -1.137974                  None\n1                W2_continuous  2.571330                  None\n2                X1_continuous  0.254323                  None\n3                X2_continuous -0.104112                  None\n4                    T1_binary -0.912958                  None\n5  int_T1_binary_X1_continuous -1.904831                  None\n6  int_T1_binary_X2_continuous -0.887939                  None"
  },
  {
    "objectID": "01_Home/installation.html",
    "href": "01_Home/installation.html",
    "title": "Installation",
    "section": "",
    "text": "The most recent version of CamML can be install via :\npip install caml\nand pinned to a specific version via:\npip install caml=={version}\nTo install optional/extra dependencies, run:\npip install 'caml[extra]'\nWe currently support the following extras: pyspark & polars.\nNote: CaML is in a highly experimental state and no stable release exists. Breaking changes to the API may occur at any time.\n\n\n\n Back to top",
    "crumbs": [
      "Installation"
    ]
  },
  {
    "objectID": "02_Concepts/motivation.html",
    "href": "02_Concepts/motivation.html",
    "title": "Motivation",
    "section": "",
    "text": "Forthcoming\n\n\n\n Back to top",
    "crumbs": [
      "Motivation"
    ]
  },
  {
    "objectID": "03_Examples/CamlCATE.html",
    "href": "03_Examples/CamlCATE.html",
    "title": "CamlCATE API Usage",
    "section": "",
    "text": "Here we’ll walk through an example of generating synthetic data, running CamlCATE, and visualizing results using the ground truth as reference.",
    "crumbs": [
      "CamlCATE API Usage"
    ]
  },
  {
    "objectID": "03_Examples/CamlCATE.html#generate-synthetic-data",
    "href": "03_Examples/CamlCATE.html#generate-synthetic-data",
    "title": "CamlCATE API Usage",
    "section": "Generate Synthetic Data",
    "text": "Generate Synthetic Data\nHere we’ll leverage the CamlSyntheticDataGenerator class to generate a linear synthetic data generating process, with a binary treatment, continuous outcome, and a mix of confounding/mediating continuous covariates.\n\nfrom caml.extensions.synthetic_data import CamlSyntheticDataGenerator\n\ndata =  CamlSyntheticDataGenerator(n_obs=10_000,\n                                  n_cont_outcomes=1,\n                                  n_binary_treatments=1,\n                                  n_cont_confounders=2,\n                                  n_cont_modifiers=2,\n                                  n_confounding_modifiers=1,\n                                  causal_model_functional_form=\"linear\",\n                                  n_nonlinear_transformations=5,\n                                  n_nonlinear_interactions=2,\n                                  seed=1)\n\nWe can print our simulated data via:\n\ndata.df\n\n\n\n\n\n\n\n\nW1_continuous\nW2_continuous\nX1_continuous\nX2_continuous\nT1_binary\nY1_continuous\n\n\n\n\n0\n0.212951\n2.427782\n4.855579\n1.899164\n1\n-15.626184\n\n\n1\n15.593752\n7.556136\n4.087682\n-0.574265\n1\n-6.393739\n\n\n2\n1.062978\n3.644116\n4.970670\n0.091263\n1\n-13.628719\n\n\n3\n0.334657\n4.581727\n3.524831\n0.235195\n1\n-9.546798\n\n\n4\n5.221081\n3.886017\n0.487610\n-0.677476\n1\n0.070117\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n9995\n0.408012\n4.600472\n1.411209\n1.882209\n1\n-3.247035\n\n\n9996\n2.639800\n6.699876\n0.001684\n2.976786\n1\n2.582407\n\n\n9997\n1.151358\n7.453297\n1.133279\n2.428612\n1\n-0.491604\n\n\n9998\n1.073735\n8.631265\n1.431656\n2.058397\n1\n-0.964414\n\n\n9999\n0.662806\n5.282546\n0.214802\n2.999912\n1\n1.087057\n\n\n\n\n10000 rows × 6 columns\n\n\n\nTo inspect our true data generating process, we can call data.dgp. Furthermore, we will have our true CATEs and ATEs at our disposal via data.cates & data.ates, respectively. We’ll use this as our source of truth for performance evaluation of our CATE estimator.\n\nfor t, df in data.dgp.items():\n    print(f\"\\nDGP for {t}:\")\n    print(df)\n\n\nDGP for T1_binary:\n      covariates    params global_transformation\n0  W1_continuous  1.003484               Sigmoid\n1  W2_continuous  2.968150               Sigmoid\n2  X1_continuous  1.551445               Sigmoid\n\nDGP for Y1_continuous:\n                    covariates    params global_transformation\n0                W1_continuous  0.431376                  None\n1                W2_continuous  0.287855                  None\n2                X1_continuous -2.663734                  None\n3                X2_continuous  1.842291                  None\n4                    T1_binary -0.656965                  None\n5  int_T1_binary_X1_continuous -0.549627                  None\n6  int_T1_binary_X2_continuous -1.580467                  None\n\n\n\ndata.cates\n\n\n\n\n\n\n\n\nCATE_of_T1_binary_on_Y1_continuous\n\n\n\n\n0\n-6.327288\n\n\n1\n-1.996057\n\n\n2\n-3.533216\n\n\n3\n-2.966024\n\n\n4\n0.145760\n\n\n...\n...\n\n\n9995\n-4.407371\n\n\n9996\n-5.362603\n\n\n9997\n-5.118186\n\n\n9998\n-4.697070\n\n\n9999\n-5.516288\n\n\n\n\n10000 rows × 1 columns\n\n\n\n\ndata.ates\n\n\n\n\n\n\n\n\nTreatment\nATE\n\n\n\n\n0\nT1_binary_on_Y1_continuous\n-3.593735",
    "crumbs": [
      "CamlCATE API Usage"
    ]
  },
  {
    "objectID": "03_Examples/CamlCATE.html#running-camlcate",
    "href": "03_Examples/CamlCATE.html#running-camlcate",
    "title": "CamlCATE API Usage",
    "section": "Running CamlCATE",
    "text": "Running CamlCATE\n\nClass Instantiation\nWe can instantiate and observe our CamlCATE object via:\n\n💡 Tip: W can be leveraged if we want to use certain covariates only in our nuisance functions to control for confounding and not in the final CATE estimator. This can be useful if a confounder may be required to include, but for compliance reasons, we don’t want our CATE model to leverage this feature (e.g., gender). However, this will restrict our available CATE estimators to orthogonal learners, since metalearners necessarily include all covariates. If you don’t care about W being in the final CATE estimator, pass it as X, as done below.\n\n\nfrom caml import CamlCATE\n\ncaml_obj = CamlCATE(df=data.df,\n                Y=\"Y1_continuous\",\n                T=\"T1_binary\",\n                X=[c for c in data.df.columns if 'X' in c]\n                    + [c for c in data.df.columns if 'W' in c],\n                discrete_treatment=True,\n                discrete_outcome=False)\n\n\nprint(caml_obj)\n\n================== CamlCATE Object ==================\nData Backend: pandas\nNo. of Observations: 10,000\nOutcome Variable: Y1_continuous\nDiscrete Outcome: False\nTreatment Variable: T1_binary\nDiscrete Treatment: True\nFeatures/Confounders for Heterogeneity (X): ['X1_continuous', 'X2_continuous', 'W1_continuous', 'W2_continuous']\nFeatures/Confounders as Controls (W): []\nRandom Seed: None\n\n\n\n\n\nNuisance Function AutoML\nWe can then obtain our nuisance functions / regression & propensity models via Flaml AutoML:\n\ncaml_obj.auto_nuisance_functions(\n    flaml_Y_kwargs={\"time_budget\": 30,\n                    \"verbose\":0,\n                    \"estimator_list\":[\"rf\", \"extra_tree\", \"xgb_limitdepth\"]},\n    flaml_T_kwargs={\"time_budget\": 30,\n                    \"verbose\":0,\n                    \"estimator_list\":[\"rf\", \"extra_tree\", \"xgb_limitdepth\"]},\n)\n\n\nprint(caml_obj.model_Y_X_W)\nprint(caml_obj.model_Y_X_W_T)\nprint(caml_obj.model_T_X_W)\n\nExtraTreesRegressor(max_features=0.8120734525770129, max_leaf_nodes=877,\n                    n_estimators=344, n_jobs=-1, random_state=12032022)\nExtraTreesRegressor(max_features=0.979760061664647, max_leaf_nodes=792,\n                    n_estimators=157, n_jobs=-1, random_state=12032022)\nExtraTreesClassifier(max_features=0.37267795773849954, max_leaf_nodes=4,\n                     n_estimators=5, n_jobs=-1, random_state=12032022)\n\n\n\n\nFit CATE Estimators\nNow that we have obtained our first-stage models, we can fit our CATE estimators via:\n\n📝 Note: The selected model defaults to the one with the highest RScore. All fitted models are still accessible via the cate_estimators attribute and if you want to change default estimator, you can run caml_obj._validation_estimator = {different_model}.\n\n\n🚀Forthcoming: Additional scoring techniques & AutoML for CATE estimators is on our roadmap.\n\n\ncaml_obj.fit_validator(\n    cate_estimators=[\n        \"LinearDML\",\n        \"CausalForestDML\",\n        \"ForestDRLearner\",\n        \"LinearDRLearner\",\n        \"DomainAdaptationLearner\",\n        \"SLearner\",\n        \"TLearner\",\n        \"XLearner\",\n    ],\n    validation_size=0.2,\n    test_size=0.2,\n    n_jobs=-1,\n)\n\n\ncaml_obj.validation_estimator\n\n&lt;econml.dml.dml.LinearDML at 0x777f7115e920&gt;\n\n\n\ncaml_obj.cate_estimators\n\n[('LinearDML', &lt;econml.dml.dml.LinearDML at 0x777f5bbc77f0&gt;),\n ('CausalForestDML',\n  &lt;econml.dml.causal_forest.CausalForestDML at 0x777f45f00790&gt;),\n ('ForestDRLearner', &lt;econml.dr._drlearner.ForestDRLearner at 0x777f45f01ea0&gt;),\n ('LinearDRLearner', &lt;econml.dr._drlearner.LinearDRLearner at 0x777fb41ee830&gt;),\n ('DomainAdaptationLearner',\n  &lt;econml.metalearners._metalearners.DomainAdaptationLearner at 0x777fb41d6740&gt;),\n ('SLearner', &lt;econml.metalearners._metalearners.SLearner at 0x777fb41d6890&gt;),\n ('TLearner', &lt;econml.metalearners._metalearners.TLearner at 0x777f462e52a0&gt;),\n ('XLearner', &lt;econml.metalearners._metalearners.XLearner at 0x777f462e7850&gt;)]\n\n\n\n\nValidate model on test hold out set\nHere we can validate our model on the test hold out set. Currently, this is only available for when continuous outcomes and binary treatments exist.\n\ncaml_obj.validate()\n\n   treatment  blp_est  blp_se  blp_pval  qini_est  qini_se  qini_pval  autoc_est  autoc_se  autoc_pval  cal_r_squared\n0          1    0.947   0.054       0.0      0.63    0.042        0.0      1.608     0.103         0.0          0.814\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRefit our selected model on the entire dataset\nNow that we have selected our top performer and validated results on the test set, we can fit our final model on the entire dataset.\n\ncaml_obj.fit_final()\n\n\ncaml_obj.final_estimator\n\n&lt;econml.dml.dml.LinearDML at 0x777f7089d030&gt;",
    "crumbs": [
      "CamlCATE API Usage"
    ]
  },
  {
    "objectID": "03_Examples/CamlCATE.html#validating-results-with-ground-truth",
    "href": "03_Examples/CamlCATE.html#validating-results-with-ground-truth",
    "title": "CamlCATE API Usage",
    "section": "Validating Results with Ground Truth",
    "text": "Validating Results with Ground Truth\nFirst, we will obtain our predictions.\n\ncate_predictions = caml_obj.predict()\n\n\nAverage Treatment Effect (ATE)\nWe’ll use the summarize() method after obtaining our predictions above, where our the displayed mean represents our Average Treatment Effect (ATE).\n\ncaml_obj.summarize()\n\n\n\n\n\n\n\n\ncate_predictions_0_1\n\n\n\n\ncount\n10000.000000\n\n\nmean\n-3.576367\n\n\nstd\n2.331871\n\n\nmin\n-19.823161\n\n\n25%\n-5.177071\n\n\n50%\n-3.543181\n\n\n75%\n-1.781926\n\n\nmax\n1.376626\n\n\n\n\n\n\n\nNow comparing this to our ground truth, we see the model performed well the true ATE:\n\ndata.ates\n\n\n\n\n\n\n\n\nTreatment\nATE\n\n\n\n\n0\nT1_binary_on_Y1_continuous\n-3.593735\n\n\n\n\n\n\n\n\n\nConditional Average Treatment Effect (CATE)\nNow we want to see how the estimator performed in modeling the true CATEs.\nFirst, we can simply compute the Precision in Estimating Heterogeneous Effects (PEHE), which is simply the Mean Squared Error (MSE):\n\nfrom sklearn.metrics import mean_squared_error\n\ntrue_cates = data.cates.iloc[:, 0]\nmean_squared_error(true_cates,cate_predictions)\n\n0.022760482321199153\n\n\nNot bad! Now let’s use some visualization techniques:\n\nfrom caml.extensions.plots import cate_true_vs_estimated_plot\n\ncate_true_vs_estimated_plot(true_cates=true_cates, estimated_cates=cate_predictions)\n\n\n\n\n\n\n\n\n\nfrom caml.extensions.plots import cate_histogram_plot\n\ncate_histogram_plot(true_cates=true_cates, estimated_cates=cate_predictions)\n\n\n\n\n\n\n\n\n\nfrom caml.extensions.plots import cate_line_plot\n\ncate_line_plot(true_cates=true_cates, estimated_cates=cate_predictions, window=20)\n\n\n\n\n\n\n\n\nOverall, we can see the model performed remarkably well!~",
    "crumbs": [
      "CamlCATE API Usage"
    ]
  },
  {
    "objectID": "03_Examples/CamlCATE.html#obtaining-model-objects-artifacts-for-production-systems",
    "href": "03_Examples/CamlCATE.html#obtaining-model-objects-artifacts-for-production-systems",
    "title": "CamlCATE API Usage",
    "section": "Obtaining Model Objects & Artifacts for Production Systems",
    "text": "Obtaining Model Objects & Artifacts for Production Systems\nIn many production settings, we will want to store our model, information on the features used, etc. We provide attributes that to pull key information (more to be added later as class evolves)\nGrabbing final model object:\n\ncaml_obj.final_estimator\n\n&lt;econml.dml.dml.LinearDML at 0x777f7089d030&gt;\n\n\nGrabbing input features:\n\ncaml_obj.input_names\n\n{'feature_names': ['X1_continuous',\n  'X2_continuous',\n  'W1_continuous',\n  'W2_continuous'],\n 'output_names': 'Y1_continuous',\n 'treatment_names': 'T1_binary'}\n\n\nGrabbing all fitted CATE estimators:\n\ncaml_obj.cate_estimators\n\n[('LinearDML', &lt;econml.dml.dml.LinearDML at 0x777f5bbc77f0&gt;),\n ('CausalForestDML',\n  &lt;econml.dml.causal_forest.CausalForestDML at 0x777f45f00790&gt;),\n ('ForestDRLearner', &lt;econml.dr._drlearner.ForestDRLearner at 0x777f45f01ea0&gt;),\n ('LinearDRLearner', &lt;econml.dr._drlearner.LinearDRLearner at 0x777fb41ee830&gt;),\n ('DomainAdaptationLearner',\n  &lt;econml.metalearners._metalearners.DomainAdaptationLearner at 0x777fb41d6740&gt;),\n ('SLearner', &lt;econml.metalearners._metalearners.SLearner at 0x777fb41d6890&gt;),\n ('TLearner', &lt;econml.metalearners._metalearners.TLearner at 0x777f462e52a0&gt;),\n ('XLearner', &lt;econml.metalearners._metalearners.XLearner at 0x777f462e7850&gt;)]",
    "crumbs": [
      "CamlCATE API Usage"
    ]
  },
  {
    "objectID": "05_Contributors/testing.html",
    "href": "05_Contributors/testing.html",
    "title": "Testing",
    "section": "",
    "text": "We utilize marimo notebooks under the notebooks/dev/ directory for testing the api. After setting up the environment, you can run marimo edit to host notebook server on your local machine. For any examples worth including in the documentation, we add these notebooks to the notebooks/examples/ directory.\nFeel free to go about your development process however you see fit, but for any major functionality changes, make sure any examples are updated accordingly. If you choose to develop with Jupyter notebooks, you can convert to marimo via marimo convert *.ipynb -o *.py and vice-versa.",
    "crumbs": [
      "Testing"
    ]
  },
  {
    "objectID": "05_Contributors/testing.html#informal-testingdevelopment",
    "href": "05_Contributors/testing.html#informal-testingdevelopment",
    "title": "Testing",
    "section": "",
    "text": "We utilize marimo notebooks under the notebooks/dev/ directory for testing the api. After setting up the environment, you can run marimo edit to host notebook server on your local machine. For any examples worth including in the documentation, we add these notebooks to the notebooks/examples/ directory.\nFeel free to go about your development process however you see fit, but for any major functionality changes, make sure any examples are updated accordingly. If you choose to develop with Jupyter notebooks, you can convert to marimo via marimo convert *.ipynb -o *.py and vice-versa.",
    "crumbs": [
      "Testing"
    ]
  },
  {
    "objectID": "05_Contributors/testing.html#formal-testing",
    "href": "05_Contributors/testing.html#formal-testing",
    "title": "Testing",
    "section": "Formal Testing",
    "text": "Formal Testing\nWe utilize pytest for testing our codebase.\n\nUnit Testing\nUnit tests are under the tests/caml/ directory following the same structure of the caml/ prefixed by “test_”. For example, if we wanted to write tests for cate.py, we would create a new file to build these tests tests/caml/core/test_cate.py.\nTo run unit tests, simply run pytest from command line. This will run your unit tests (with respective output printed in terminal).\nAdditionally, an html report of the coverage will be exported to tests/reports/htmlcov, which can be a useful tool for interactively evaluating the coverage of your unit tests.\n\n\nAdvanced Testing\nUnit tests are automatically run during PR process via GitHub Actions. Integration & regression testing forthcoming.",
    "crumbs": [
      "Testing"
    ]
  },
  {
    "objectID": "05_Contributors/getting_started.html",
    "href": "05_Contributors/getting_started.html",
    "title": "Contributing to CaML",
    "section": "",
    "text": "Welcome to the CaML contributor guide!\nWe manage out project via Github and leverage Github Flow for managing our development process. This guide will help you get started as a contributor and guide you through the process of contributing to CaML.",
    "crumbs": [
      "Contributing to CaML"
    ]
  },
  {
    "objectID": "05_Contributors/getting_started.html#general-contribution-guide",
    "href": "05_Contributors/getting_started.html#general-contribution-guide",
    "title": "Contributing to CaML",
    "section": "General Contribution Guide",
    "text": "General Contribution Guide\nPull requests are the best way to make changes to CaML:\n\nFork the repo and create your branch from main branch\nClone the repository on your local machine\nFor environment setup, see Environment Setup\nFor documentation, see Documentation\nFor testing, see Testing\nCreate a pull request & fill out the generated PR template\n\nCaML follows conventional commits for our PR titles, see here for more details.\nAll github actions & checks will be required to complete successfully prior to merging.",
    "crumbs": [
      "Contributing to CaML"
    ]
  },
  {
    "objectID": "05_Contributors/getting_started.html#report-bugs-using-github-issues",
    "href": "05_Contributors/getting_started.html#report-bugs-using-github-issues",
    "title": "Contributing to CaML",
    "section": "Report Bugs using Github Issues",
    "text": "Report Bugs using Github Issues\nBugs, features, and any other feedback can be submitted using the Github issues page.",
    "crumbs": [
      "Contributing to CaML"
    ]
  },
  {
    "objectID": "05_Contributors/documentation.html",
    "href": "05_Contributors/documentation.html",
    "title": "Documentation",
    "section": "",
    "text": "This repository uses  & quartodoc for documentation. All files relating to the documentation are under the docs/ directory. Quarto & quartodoc provide very detailed documentation on usage so I will refer the reader to these resources for more details.\nTo build the documentation, run the following command from the projects root directory:\nquartodoc build --config docs/_quarto.yml\nAnd to preview the documentation, run the following command:\nquarto preview docs/\nThe documentation preview will be hosted on http://localhost:8000/. Note that the quarto preview will be checking for live updates & applying them in real-time. In some cases, the changes will not manifest until you rerun quartodoc build --config docs/_quarto.yml. In general, this will occur when you make changes to the “quartodoc:” section of the docs/_quarto.yml file or any corresponding API changes.\n\n\n\n Back to top",
    "crumbs": [
      "Documentation"
    ]
  },
  {
    "objectID": "05_Contributors/conventional_commits.html",
    "href": "05_Contributors/conventional_commits.html",
    "title": "Conventional Commits",
    "section": "",
    "text": "This project uses conventional commits for Pull Request titles, as they are ultimately used as the commit names on the main branch. What are conventional commits? In the words of the official documentation:\n\nThe Conventional Commits specification is a lightweight convention on top of commit messages. It provides an easy set of rules for creating an explicit commit history; which makes it easier to write automated tools on top of.\n\nThe PR titles should thus take the general form:\n&lt;type&gt;[optional scope]: &lt;description&gt;\nAn example would be:\nfix(types): make all floats double\nValid types for Caml are as follows:\n\nbuild: Changes that affect the build system or external dependencies\nci: Changes to our CI/CD configuration files and scripts\ndocs: Documentation only changes\nfeat: A new feature\nfix: A bug fix\nperf: A code change that improves performance\nrefactor: A code change that neither fixes a bug nor adds a feature\nstyle: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)\ntest: Adding missing tests or correcting existing tests\nrevert: Reverting code changes to a previous state\nchore: Routine tasks that don’t fit in any of the above\n\nWe use the following regex to validate PR titles (test it!):\n^(build|chore|ci|docs|feat|fix|perf|refactor|revert|style|test|release)(.+)?(!)?:\\ .+\n\n\n\n Back to top",
    "crumbs": [
      "Conventional Commits"
    ]
  },
  {
    "objectID": "05_Contributors/environment.html",
    "href": "05_Contributors/environment.html",
    "title": "Environment Setup",
    "section": "",
    "text": "To help aid in environment setup, we’ve created a VS Code devcontainer for quick, isolated, and standardized environment creation.\n\n\n\nDocker Desktop or your choice of docker engine\nVisual Studio Code\n\n\n\n\n\nEnsure docker engine is running\nOpen VSCode in cloned project directory\nInstall VSCode Dev Containers extension\nOpen the current folder in dev container",
    "crumbs": [
      "Environment Setup"
    ]
  },
  {
    "objectID": "05_Contributors/environment.html#with-vscode-devcontainers",
    "href": "05_Contributors/environment.html#with-vscode-devcontainers",
    "title": "Environment Setup",
    "section": "",
    "text": "To help aid in environment setup, we’ve created a VS Code devcontainer for quick, isolated, and standardized environment creation.\n\n\n\nDocker Desktop or your choice of docker engine\nVisual Studio Code\n\n\n\n\n\nEnsure docker engine is running\nOpen VSCode in cloned project directory\nInstall VSCode Dev Containers extension\nOpen the current folder in dev container",
    "crumbs": [
      "Environment Setup"
    ]
  },
  {
    "objectID": "05_Contributors/environment.html#without-devcontainers",
    "href": "05_Contributors/environment.html#without-devcontainers",
    "title": "Environment Setup",
    "section": "Without Devcontainers",
    "text": "Without Devcontainers\n\nPrerequisites\n\nuv v0.6.10\npython v3.10\n\n\n\nSetup\n\nOpen repository in ide of choice\nRun uv sync --all-groups --frozen from command line\nActivate the virtual environment via source .venv/bin/activate\nRun pre-commit install to install pre-commit hooks",
    "crumbs": [
      "Environment Setup"
    ]
  },
  {
    "objectID": "05_Contributors/environment.html#project-package-dependency-management",
    "href": "05_Contributors/environment.html#project-package-dependency-management",
    "title": "Environment Setup",
    "section": "Project & Package Dependency Management",
    "text": "Project & Package Dependency Management\nWe use uv for dependency & project management. See uv docs for details.",
    "crumbs": [
      "Environment Setup"
    ]
  },
  {
    "objectID": "03_Examples/Synthetic Data Generation.html",
    "href": "03_Examples/Synthetic Data Generation.html",
    "title": "Caml Synthetic Data API Usage",
    "section": "",
    "text": "from caml.extensions.synthetic_data import CamlSyntheticDataGenerator",
    "crumbs": [
      "Caml Synthetic Data API Usage"
    ]
  },
  {
    "objectID": "03_Examples/Synthetic Data Generation.html#generate-data",
    "href": "03_Examples/Synthetic Data Generation.html#generate-data",
    "title": "Caml Synthetic Data API Usage",
    "section": "Generate Data",
    "text": "Generate Data\n\ndata =  CamlSyntheticDataGenerator(n_obs=10_000,\n                                  n_cont_outcomes=1,\n                                  n_binary_outcomes=1,\n                                  n_cont_treatments=1,\n                                  n_binary_treatments=1,\n                                  n_discrete_treatments=1,\n                                  n_cont_confounders=1,\n                                  n_binary_confounders=1,\n                                  n_discrete_confounders=1,\n                                  n_cont_modifiers=1,\n                                  n_binary_modifiers=1,\n                                  n_discrete_modifiers=1,\n                                  n_confounding_modifiers=1,\n                                  stddev_outcome_noise=3,\n                                  stddev_treatment_noise=3,\n                                  causal_model_functional_form=\"linear\",\n                                  n_nonlinear_transformations=10,\n                                  n_nonlinear_interactions=5,\n                                  seed=15)",
    "crumbs": [
      "Caml Synthetic Data API Usage"
    ]
  },
  {
    "objectID": "03_Examples/Synthetic Data Generation.html#simulated-dataframe",
    "href": "03_Examples/Synthetic Data Generation.html#simulated-dataframe",
    "title": "Caml Synthetic Data API Usage",
    "section": "Simulated Dataframe",
    "text": "Simulated Dataframe\n\ndata.df\n\n\n\n\n\n\n\n\nW1_continuous\nW2_binary\nW3_discrete\nX1_continuous\nX2_binary\nX3_discrete\nT1_continuous\nT2_binary\nT3_discrete\nY1_continuous\nY2_binary\n\n\n\n\n0\n0.706567\n1\n0\n-1.652559\n1\n1\n2.494731\n1\n1\n-25.198250\n1\n\n\n1\n3.315282\n1\n2\n-2.775285\n1\n0\n7.464238\n0\n0\n-70.792577\n1\n\n\n2\n1.908430\n1\n3\n-3.451824\n0\n1\n3.470709\n0\n1\n-43.344150\n1\n\n\n3\n3.743169\n1\n0\n-4.319313\n1\n0\n8.065827\n0\n4\n-131.063425\n1\n\n\n4\n2.781994\n1\n3\n-2.901003\n1\n0\n8.161921\n0\n4\n-107.833216\n1\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n9995\n1.853102\n0\n2\n-2.369628\n0\n1\n4.856855\n0\n0\n-30.105565\n1\n\n\n9996\n1.710607\n1\n2\n-2.642743\n1\n1\n4.286633\n0\n0\n-45.993240\n1\n\n\n9997\n4.942256\n0\n0\n-2.908543\n0\n0\n12.208850\n0\n4\n-103.391312\n1\n\n\n9998\n3.125018\n1\n1\n-3.039957\n0\n3\n15.905126\n0\n4\n-165.097366\n0\n\n\n9999\n2.500979\n0\n0\n-3.320707\n0\n3\n10.460442\n0\n4\n-127.790919\n1\n\n\n\n\n10000 rows × 11 columns",
    "crumbs": [
      "Caml Synthetic Data API Usage"
    ]
  },
  {
    "objectID": "03_Examples/Synthetic Data Generation.html#dgp",
    "href": "03_Examples/Synthetic Data Generation.html#dgp",
    "title": "Caml Synthetic Data API Usage",
    "section": "DGP",
    "text": "DGP\n\nfor k,v in data.dgp.items():\n    print(k)\n    print(v)\n\nT1_continuous\n      covariates    params global_transformation\n0  W1_continuous  2.601096                  None\n1      W2_binary -1.214932                  None\n2    W3_discrete -0.128753                  None\n3    X3_discrete  1.605966                  None\nT2_binary\n      covariates    params global_transformation\n0  W1_continuous -1.633325               Sigmoid\n1      W2_binary  0.331532               Sigmoid\n2    W3_discrete -2.018670               Sigmoid\n3    X3_discrete  0.281986               Sigmoid\nT3_discrete\n      covariates  cat_1_params  cat_2_params global_transformation\n0  W1_continuous      1.251009     -2.752482               Softmax\n1      W2_binary     -0.364808      2.056047               Softmax\n2    W3_discrete     -0.068131      1.673660               Softmax\n3    X3_discrete      1.310578      2.357792               Softmax\nY1_continuous\n                         covariates    params global_transformation\n0                     W1_continuous -1.553833                  None\n1                         W2_binary -2.998091                  None\n2                       W3_discrete -2.915301                  None\n3                     X1_continuous -1.813285                  None\n4                         X2_binary  0.739353                  None\n5                       X3_discrete  0.082275                  None\n6                     T1_continuous -1.643250                  None\n7                         T2_binary -0.409790                  None\n8                       T3_discrete -2.571727                  None\n9   int_T1_continuous_X1_continuous  1.374265                  None\n10      int_T1_continuous_X2_binary -2.330711                  None\n11    int_T1_continuous_X3_discrete -0.588478                  None\n12      int_T2_binary_X1_continuous -1.927494                  None\n13          int_T2_binary_X2_binary -0.416015                  None\n14        int_T2_binary_X3_discrete -1.346297                  None\n15    int_T3_discrete_X1_continuous  1.974255                  None\n16        int_T3_discrete_X2_binary -0.304700                  None\n17      int_T3_discrete_X3_discrete -0.754942                  None\nY2_binary\n                         covariates    params global_transformation\n0                     W1_continuous -0.906427               Sigmoid\n1                         W2_binary -2.316021               Sigmoid\n2                       W3_discrete  0.545442               Sigmoid\n3                     X1_continuous -0.204994               Sigmoid\n4                         X2_binary  0.417902               Sigmoid\n5                       X3_discrete  2.195866               Sigmoid\n6                     T1_continuous  2.169852               Sigmoid\n7                         T2_binary -2.210767               Sigmoid\n8                       T3_discrete -2.387556               Sigmoid\n9   int_T1_continuous_X1_continuous -0.145369               Sigmoid\n10      int_T1_continuous_X2_binary -1.010015               Sigmoid\n11    int_T1_continuous_X3_discrete -1.460272               Sigmoid\n12      int_T2_binary_X1_continuous  1.614527               Sigmoid\n13          int_T2_binary_X2_binary  2.939611               Sigmoid\n14        int_T2_binary_X3_discrete -0.418421               Sigmoid\n15    int_T3_discrete_X1_continuous -2.972694               Sigmoid\n16        int_T3_discrete_X2_binary  2.586574               Sigmoid\n17      int_T3_discrete_X3_discrete -1.248249               Sigmoid",
    "crumbs": [
      "Caml Synthetic Data API Usage"
    ]
  },
  {
    "objectID": "03_Examples/Synthetic Data Generation.html#true-conditional-average-treatment-effects-cates",
    "href": "03_Examples/Synthetic Data Generation.html#true-conditional-average-treatment-effects-cates",
    "title": "Caml Synthetic Data API Usage",
    "section": "True Conditional Average Treatment Effects (CATEs)",
    "text": "True Conditional Average Treatment Effects (CATEs)\n\ndata.cates\n\n\n\n\n\n\n\n\nCATE_of_T1_continuous_on_Y1_continuous\nCATE_of_T2_binary_on_Y1_continuous\nCATE_of_T3_discrete_on_Y1_continuous_level_1_v_0\nCATE_of_T3_discrete_on_Y1_continuous_level_4_v_0\nCATE_of_T3_discrete_on_Y1_continuous_level_3_v_0\nCATE_of_T3_discrete_on_Y1_continuous_level_2_v_0\nCATE_of_T1_continuous_on_Y2_binary\nCATE_of_T2_binary_on_Y2_binary\nCATE_of_T3_discrete_on_Y2_binary_level_1_v_0\nCATE_of_T3_discrete_on_Y2_binary_level_4_v_0\nCATE_of_T3_discrete_on_Y2_binary_level_3_v_0\nCATE_of_T3_discrete_on_Y2_binary_level_2_v_0\n\n\n\n\n0\n-6.833492\n1.013194\n-6.893941\n-27.575765\n-20.681824\n-13.787882\n0.000000\n0.000000\n0.166471\n0.166471\n0.166471\n0.166471\n\n\n1\n-7.787938\n4.523539\n-8.355547\n-33.422188\n-25.066641\n-16.711094\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\n2\n-6.975448\n4.897281\n-10.141449\n-40.565795\n-30.424346\n-20.282897\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\n3\n-9.909840\n7.499642\n-11.403851\n-45.615403\n-34.211552\n-22.807702\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\n4\n-7.960707\n4.765859\n-8.603745\n-34.414982\n-25.811236\n-17.207491\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n9995\n-5.488225\n2.811356\n-8.004919\n-32.019678\n-24.014758\n-16.009839\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\n9996\n-8.194268\n2.921768\n-8.848818\n-35.395272\n-26.546454\n-17.697636\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\n9997\n-5.640359\n5.196408\n-8.313932\n-33.255728\n-24.941796\n-16.627864\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\n9998\n-7.586390\n1.410815\n-10.838203\n-43.352811\n-32.514608\n-21.676405\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\n9999\n-7.972215\n1.951960\n-11.392476\n-45.569903\n-34.177427\n-22.784951\n-0.347813\n-0.800617\n0.000000\n0.800617\n0.069235\n0.000000\n\n\n\n\n10000 rows × 12 columns",
    "crumbs": [
      "Caml Synthetic Data API Usage"
    ]
  },
  {
    "objectID": "03_Examples/Synthetic Data Generation.html#true-average-treatment-effects-ates",
    "href": "03_Examples/Synthetic Data Generation.html#true-average-treatment-effects-ates",
    "title": "Caml Synthetic Data API Usage",
    "section": "True Average Treatment Effects (ATEs)",
    "text": "True Average Treatment Effects (ATEs)\n\ndata.ates\n\n\n\n\n\n\n\n\nTreatment\nATE\n\n\n\n\n0\nT1_continuous_on_Y1_continuous\n-7.420280\n\n\n1\nT2_binary_on_Y1_continuous\n3.120486\n\n\n2\nT3_discrete_on_Y1_continuous_level_1_v_0\n-9.381688\n\n\n3\nT3_discrete_on_Y1_continuous_level_4_v_0\n-37.526754\n\n\n4\nT3_discrete_on_Y1_continuous_level_3_v_0\n-28.145065\n\n\n5\nT3_discrete_on_Y1_continuous_level_2_v_0\n-18.763377\n\n\n6\nT1_continuous_on_Y2_binary\n-0.000474\n\n\n7\nT2_binary_on_Y2_binary\n-0.109855\n\n\n8\nT3_discrete_on_Y2_binary_level_1_v_0\n0.139524\n\n\n9\nT3_discrete_on_Y2_binary_level_4_v_0\n0.247014\n\n\n10\nT3_discrete_on_Y2_binary_level_3_v_0\n0.219988\n\n\n11\nT3_discrete_on_Y2_binary_level_2_v_0\n0.186775",
    "crumbs": [
      "Caml Synthetic Data API Usage"
    ]
  },
  {
    "objectID": "02_Concepts/theory.html",
    "href": "02_Concepts/theory.html",
    "title": "Econometric Theory",
    "section": "",
    "text": "Forthcoming\n\n\n\n Back to top",
    "crumbs": [
      "Econometric Theory"
    ]
  },
  {
    "objectID": "01_Home/quickstart.html",
    "href": "01_Home/quickstart.html",
    "title": "Tutorial: Quick Start",
    "section": "",
    "text": "Forthcoming\n\n\n\n Back to top",
    "crumbs": [
      "Tutorial: Quick Start"
    ]
  },
  {
    "objectID": "04_Reference/make_fully_heterogeneous_dataset.html",
    "href": "04_Reference/make_fully_heterogeneous_dataset.html",
    "title": "make_fully_heterogeneous_dataset",
    "section": "",
    "text": "make_fully_heterogeneous_dataset(\n    n_obs=1000,\n    n_confounders=5,\n    theta=4.0,\n    seed=None,\n    **doubleml_kwargs,\n)\nSimulate data generating process from an interactive regression model with fully heterogenous treatment effects.\nThe outcome is continuous and the treatment is binary. The dataset is generated using a modified version of make_irm_data function from the doubleml package.\nThe general form of the data generating process is:\n\\[\ny_i= g(d_i,\\mathbf{X_i})+\\epsilon_i\n\\] \\[\nd_i=f(\\mathbf{X_i})+\\eta_i\n\\]\nwhere \\(y_i\\) is the outcome, \\(d_i\\) is the treatment, \\(\\mathbf{X_i}\\) are the confounders utilized for full effect heterogeneity, \\(\\epsilon_i\\) and \\(\\eta_i\\) are the error terms, \\(g\\) is the outcome function, and \\(f\\) is the treatment function.\nSee the doubleml documentation for more details on the specific functional forms of the data generating process.\nNote that the treatment effect is fully heterogenous, thus the CATE is defined as: \\(\\\\tau = \\\\mathbb{E}[g(1,\\mathbf{X}) - g(0,\\mathbf{X})|\\mathbf{X}]\\) for any \\(\\mathbf{X}\\).\nThe ATE is defined as the average of the CATE function over all observations: \\(\\mathbb{E}[\\\\tau (\\cdot)]\\)\nAs a DAG, the data generating process can be roughly represented as:"
  },
  {
    "objectID": "04_Reference/make_fully_heterogeneous_dataset.html#parameters",
    "href": "04_Reference/make_fully_heterogeneous_dataset.html#parameters",
    "title": "make_fully_heterogeneous_dataset",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn_obs\nint\nThe number of observations to generate.\n1000\n\n\nn_confounders\nint\nThe number of confounders \\(\\mathbf{X_i}\\) to generate (these are utilized fully for heterogeneity).\n5\n\n\ntheta\nfloat\nThe base parameter for the treatment effect. Note this differs from the ATE.\n4.0\n\n\nseed\nint | None\nThe seed to use for the random number generator.\nNone\n\n\n**doubleml_kwargs\n\nAdditional keyword arguments to pass to the data generating process.\n{}"
  },
  {
    "objectID": "04_Reference/make_fully_heterogeneous_dataset.html#returns",
    "href": "04_Reference/make_fully_heterogeneous_dataset.html#returns",
    "title": "make_fully_heterogeneous_dataset",
    "section": "Returns",
    "text": "Returns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ndf\npandas.DataFrame\nThe generated dataset where y is the outcome, d is the treatment, and X are the confounders which are fully utilized for heterogeneity.\n\n\ntrue_cates\nnumpy.ndarray\nThe true conditional average treatment effects.\n\n\ntrue_ate\nfloat\nThe true average treatment effect."
  },
  {
    "objectID": "04_Reference/make_fully_heterogeneous_dataset.html#examples",
    "href": "04_Reference/make_fully_heterogeneous_dataset.html#examples",
    "title": "make_fully_heterogeneous_dataset",
    "section": "Examples",
    "text": "Examples\n\nfrom caml.extensions.synthetic_data import make_fully_heterogeneous_dataset\ndf, true_cates, true_ate = make_fully_heterogeneous_dataset(n_obs=1000,\n                                                            n_confounders=5,\n                                                            theta=4.0,\n                                                            seed=1)\n\nprint(f\"True CATEs: {true_cates[:5]}\")\nprint(f\"True ATE: {true_ate}\")\nprint(df.head())\n\nTrue CATEs: [5.10338083 5.0918794  1.93444292 4.36046179 3.89521828]\nTrue ATE: 3.9499484248360175\n         X1        X2        X3        X4        X5         y    d\n0  1.682368 -0.422572 -1.219871 -0.941586 -1.270241  5.828931  1.0\n1  0.684154  1.125168  2.601475  0.441070  0.889493  4.767675  1.0\n2 -2.035148 -1.386116 -0.770108 -0.070788 -0.524494  2.748786  1.0\n3  0.429364 -0.125604 -0.095252 -0.033939  1.243388  5.140932  1.0\n4  0.240024 -0.069628 -1.722948 -1.565808 -1.494064  2.431165  1.0"
  },
  {
    "objectID": "04_Reference/make_partially_linear_dataset_constant.html",
    "href": "04_Reference/make_partially_linear_dataset_constant.html",
    "title": "make_partially_linear_dataset_constant",
    "section": "",
    "text": "make_partially_linear_dataset_constant(\n    n_obs=1000,\n    ate=4.0,\n    n_confounders=10,\n    dgp='make_plr_CCDDHNR2018',\n    seed=None,\n    **doubleml_kwargs,\n)\nSimulate a data generating process from a partially linear model with a constant treatment effect (ATE only).\nThe outcome and treatment are both continuous.The dataset is generated using the make_plr_CCDDHNR2018 or make_plr_turrell2018 function from the doubleml package.\nThe general form of the data generating process is:\n\\[\ny_i= \\tau_0 d_i + g(\\mathbf{W_i})+\\epsilon_i\n\\] \\[\nd_i=f(\\mathbf{W_i})+\\eta_i\n\\]\nwhere \\(y_i\\) is the outcome, \\(d_i\\) is the treatment, \\(\\mathbf{W_i}\\) are the confounders, \\(\\epsilon_i\\) and \\(\\eta_i\\) are the error terms, \\(\\tau_0\\) is the ATE parameter, \\(g\\) is the outcome function, and \\(f\\) is the treatment function.\nSee the doubleml documentation for more details on the specific functional forms of the data generating process.\nAs a DAG, the data generating process can be roughly represented as:"
  },
  {
    "objectID": "04_Reference/make_partially_linear_dataset_constant.html#parameters",
    "href": "04_Reference/make_partially_linear_dataset_constant.html#parameters",
    "title": "make_partially_linear_dataset_constant",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn_obs\nint\nThe number of observations to generate.\n1000\n\n\nate\nfloat\nThe average treatment effect \\(\\tau_0\\).\n4.0\n\n\nn_confounders\nint\nThe number of confounders \\(\\mathbf{W_i}\\) to generate.\n10\n\n\ndgp\nstr\nThe data generating process to use. Can be “make_plr_CCDDHNR20” or “make_plr_turrell2018”.\n'make_plr_CCDDHNR2018'\n\n\nseed\nint | None\nThe seed to use for the random number generator.\nNone\n\n\n**doubleml_kwargs\n\nAdditional keyword arguments to pass to the data generating process.\n{}"
  },
  {
    "objectID": "04_Reference/make_partially_linear_dataset_constant.html#returns",
    "href": "04_Reference/make_partially_linear_dataset_constant.html#returns",
    "title": "make_partially_linear_dataset_constant",
    "section": "Returns",
    "text": "Returns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ndf\npandas.DataFrame\nThe generated dataset where y is the outcome, d is the treatment, and W are the confounders.\n\n\ntrue_cates\nnumpy.ndarray\nThe true conditional average treatment effects, which are all equal to the ATE here.\n\n\ntrue_ate\nfloat\nThe true average treatment effect."
  },
  {
    "objectID": "04_Reference/make_partially_linear_dataset_constant.html#examples",
    "href": "04_Reference/make_partially_linear_dataset_constant.html#examples",
    "title": "make_partially_linear_dataset_constant",
    "section": "Examples",
    "text": "Examples\n\nfrom caml.extensions.synthetic_data import make_partially_linear_dataset_constant\ndf, true_cates, true_ate = make_partially_linear_dataset_constant(n_obs=1000,\n                                                    ate=4.0,\n                                                    n_confounders=10,\n                                                    dgp=\"make_plr_CCDDHNR2018\",\n                                                    seed=1)\n\nprint(f\"True CATES: {true_cates[:5]}\")\nprint(f\"True ATE: {true_ate}\")\nprint(df.head())\n\nTrue CATES: [4. 4. 4. 4. 4.]\nTrue ATE: 4.0\n         W1        W2        W3        W4        W5        W6        W7  \\\n0 -1.799808 -0.830362 -0.775800 -2.430475 -1.759428 -0.196538 -0.392579   \n1 -2.238925 -2.107779 -1.619264 -1.816121 -2.084809 -0.456936  0.118781   \n2  1.069028  1.616054  1.959420  1.398880  0.058545  0.370891  0.161045   \n3  0.497020 -0.399126 -0.019305  0.230080  0.640361  1.233185  0.906313   \n4 -1.749809 -0.315699 -0.283176  0.439451  0.819941  0.156514  0.059722   \n\n         W8        W9       W10         y         d  \n0 -0.827537 -0.735652 -1.127103 -6.074658 -1.843476  \n1  0.270647  0.199401  0.049088 -8.534573 -1.969429  \n2  0.118180  0.438721  0.280880  4.915427  0.935840  \n3  1.031123 -0.373092  0.442367 -0.037117 -0.209740  \n4  0.472781  0.030157  1.174463 -7.922597 -1.903480"
  },
  {
    "objectID": "04_Reference/generics.experimental.html",
    "href": "04_Reference/generics.experimental.html",
    "title": "generics.experimental",
    "section": "",
    "text": "generics.experimental(obj)\nDecorator to mark functions or classes as experimental.\nThis decorator will show a warning when the decorated object is first used, indicating that it is experimental and may change in future versions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nobj\n\nThe class or function to mark as experimental\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nUnion[type, callable]\nThe decorated class or function"
  },
  {
    "objectID": "04_Reference/generics.experimental.html#parameters",
    "href": "04_Reference/generics.experimental.html#parameters",
    "title": "generics.experimental",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nobj\n\nThe class or function to mark as experimental\nrequired"
  },
  {
    "objectID": "04_Reference/generics.experimental.html#returns",
    "href": "04_Reference/generics.experimental.html#returns",
    "title": "generics.experimental",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nUnion[type, callable]\nThe decorated class or function"
  },
  {
    "objectID": "04_Reference/FastLeastSquares.html",
    "href": "04_Reference/FastLeastSquares.html",
    "title": "FastLeastSquares",
    "section": "",
    "text": "FastLeastSquares(\n    self,\n    Y,\n    T,\n    G=None,\n    X=None,\n    W=None,\n    *,\n    discrete_treatment=True,\n    engine='cpu',\n)\nFastLeastSquares is experimental and may change significantly in future versions.\nFastLeastSquares is a fast implementation of the Least Squares estimator designed specifically with Causal Inference in mind.\nThis estimator estimates a standard linear regression model for any number of continuous or binary outcomes and a single binary treatment, and provides estimates for the Average Treatment Effects (ATEs) and Group Average Treatment Effects (GATEs) out of the box. Additionally, methods are provided for estimating a specific Conditional Average Treatment Effect (CATE), as well as individual Conditional Average Treatment Effects (CATEs) for a group of observations.\nThis class leverages JAX for fast numerical computations, which can be installed using pip install caml[jax], defaulting to NumPy if JAX is not available. For GPU acceleration, install JAX with GPU support using pip install caml[jax-gpu].\nFor outcome/treatment support, see matrix.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nY\nIterable[str]\nA list of outcome variable names.\nrequired\n\n\nT\nstr\nThe treatment variable name.\nrequired\n\n\nG\nIterable[str] | None\nA list of group variable names, by default None. These will be the groups for which GATEs will be estimated.\nNone\n\n\nX\nIterable[str] | None\nA list of covariate variable names, by default None. These will be the covariates for which heterogeneity/CATEs can be estimated.\nNone\n\n\nW\nIterable[str] | None\nA list of instrument variable names, by default None. These will be the additional covariates not used for modeling heterogeneity/CATEs.\nNone\n\n\ndiscrete_treatment\nbool\nWhether the treatment is discrete, by default True\nTrue\n\n\nengine\nstr\nThe engine to use for computation, by default “cpu”. Can be “cpu” or “gpu”. Note “gpu” requires JAX to be installed, which can be installed via pip install caml[jax-gpu].\n'cpu'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nY\nIterable[str]\nA list of outcome variable names.\n\n\nT\nstr\nThe treatment variable name.\n\n\nG\nIterable[str] | None\nThe list of group variable names, by default None. These will be the groups for which GATEs will be estimated.\n\n\nX\nIterable[str] | None\nThe list of variable names representing the confounder/control feature set to be utilized for estimating heterogeneity/CATEs, that are in addition to G.\n\n\nW\nIterable[str] | None\nThe list of variable names representing the confounder/control feature not utilized for estimating heterogeneity/CATEs.\n\n\ndiscrete_treatment\nbool\nWhether the treatment is discrete, by default True\n\n\nengine\nstr\nThe engine to use for computation, by default “cpu”. Can be “cpu” or “gpu”. Note “gpu” requires JAX to be installed, which can be installed via pip install caml[jax-gpu]\n\n\nformula\nstr\nThe formula leveraged for design matrix creation via Patsy.\n\n\nresults\ndict\nA dictionary containing the results of the fitted model & estimated ATEs/GATEs.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfit\nFits the regression model on the provided data and estimates ATEs and GATEs.\n\n\n\n\n\nFastLeastSquares.fit(data, n_jobs=-1, estimate_gates=True)\nFits the regression model on the provided data and estimates ATEs and GATEs.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\nDataFrameLike\nInput data to fit the model on. Supported formats: pandas DataFrame, PySpark DataFrame, Polars DataFrame, or Any object with toPandas() or to_pandas() method\nrequired\n\n\nn_jobs\nint\nThe number of jobs to use for parallel processing in the estimation of GATEs. Defaults to -1, which uses all available processors. If getting OOM errors, try setting n_jobs to a lower value.\n-1\n\n\nestimate_gates\nbool\nWhether to estimate Group Average Treatment Effects (GATEs).\nTrue"
  },
  {
    "objectID": "04_Reference/FastLeastSquares.html#parameters",
    "href": "04_Reference/FastLeastSquares.html#parameters",
    "title": "FastLeastSquares",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nY\nIterable[str]\nA list of outcome variable names.\nrequired\n\n\nT\nstr\nThe treatment variable name.\nrequired\n\n\nG\nIterable[str] | None\nA list of group variable names, by default None. These will be the groups for which GATEs will be estimated.\nNone\n\n\nX\nIterable[str] | None\nA list of covariate variable names, by default None. These will be the covariates for which heterogeneity/CATEs can be estimated.\nNone\n\n\nW\nIterable[str] | None\nA list of instrument variable names, by default None. These will be the additional covariates not used for modeling heterogeneity/CATEs.\nNone\n\n\ndiscrete_treatment\nbool\nWhether the treatment is discrete, by default True\nTrue\n\n\nengine\nstr\nThe engine to use for computation, by default “cpu”. Can be “cpu” or “gpu”. Note “gpu” requires JAX to be installed, which can be installed via pip install caml[jax-gpu].\n'cpu'"
  },
  {
    "objectID": "04_Reference/FastLeastSquares.html#attributes",
    "href": "04_Reference/FastLeastSquares.html#attributes",
    "title": "FastLeastSquares",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nY\nIterable[str]\nA list of outcome variable names.\n\n\nT\nstr\nThe treatment variable name.\n\n\nG\nIterable[str] | None\nThe list of group variable names, by default None. These will be the groups for which GATEs will be estimated.\n\n\nX\nIterable[str] | None\nThe list of variable names representing the confounder/control feature set to be utilized for estimating heterogeneity/CATEs, that are in addition to G.\n\n\nW\nIterable[str] | None\nThe list of variable names representing the confounder/control feature not utilized for estimating heterogeneity/CATEs.\n\n\ndiscrete_treatment\nbool\nWhether the treatment is discrete, by default True\n\n\nengine\nstr\nThe engine to use for computation, by default “cpu”. Can be “cpu” or “gpu”. Note “gpu” requires JAX to be installed, which can be installed via pip install caml[jax-gpu]\n\n\nformula\nstr\nThe formula leveraged for design matrix creation via Patsy.\n\n\nresults\ndict\nA dictionary containing the results of the fitted model & estimated ATEs/GATEs."
  },
  {
    "objectID": "04_Reference/FastLeastSquares.html#methods",
    "href": "04_Reference/FastLeastSquares.html#methods",
    "title": "FastLeastSquares",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nfit\nFits the regression model on the provided data and estimates ATEs and GATEs.\n\n\n\n\n\nFastLeastSquares.fit(data, n_jobs=-1, estimate_gates=True)\nFits the regression model on the provided data and estimates ATEs and GATEs.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\nDataFrameLike\nInput data to fit the model on. Supported formats: pandas DataFrame, PySpark DataFrame, Polars DataFrame, or Any object with toPandas() or to_pandas() method\nrequired\n\n\nn_jobs\nint\nThe number of jobs to use for parallel processing in the estimation of GATEs. Defaults to -1, which uses all available processors. If getting OOM errors, try setting n_jobs to a lower value.\n-1\n\n\nestimate_gates\nbool\nWhether to estimate Group Average Treatment Effects (GATEs).\nTrue"
  },
  {
    "objectID": "04_Reference/cate_line_plot.html",
    "href": "04_Reference/cate_line_plot.html",
    "title": "cate_line_plot",
    "section": "",
    "text": "cate_line_plot(\n    estimated_cates,\n    *,\n    true_cates=None,\n    standard_errors=None,\n    alpha=0.05,\n    window=30,\n    figure_kwargs={},\n    line_kwargs={},\n)\nPlots a line plot of the ordered estimated CATEs as a rolling mean with optional confidence intervals."
  },
  {
    "objectID": "04_Reference/cate_line_plot.html#parameters",
    "href": "04_Reference/cate_line_plot.html#parameters",
    "title": "cate_line_plot",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nestimated_cates\nArrayLike\nThe estimated CATEs.\nrequired\n\n\ntrue_cates\nArrayLike | None\nThe true CATEs.\nNone\n\n\nstandard_errors\nArrayLike | None\nThe standard errors of the estimated CATEs.\nNone\n\n\nalpha\nfloat\nThe alpha level for the confidence intervals. The default is 0.05, which corresponds to 95% confidence intervals.\n0.05\n\n\nwindow\nint\nThe window size for the moving average.\n30\n\n\nfigure_kwargs\ndict\nMatplotlib figure arguments.\n{}\n\n\nline_kwargs\ndict\nMatplotlib line arguments.\n{}"
  },
  {
    "objectID": "04_Reference/cate_line_plot.html#returns",
    "href": "04_Reference/cate_line_plot.html#returns",
    "title": "cate_line_plot",
    "section": "Returns",
    "text": "Returns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nmatplotlib.pyplot.Figure\nThe line plot figure object."
  },
  {
    "objectID": "04_Reference/cate_line_plot.html#examples",
    "href": "04_Reference/cate_line_plot.html#examples",
    "title": "cate_line_plot",
    "section": "Examples",
    "text": "Examples\n\nimport numpy as np\nfrom caml.extensions.plots import cate_line_plot\n\nnp.random.seed(42)\ntrue_cates = np.random.normal(0, 1, 100)\nestimated_cates = true_cates + np.random.normal(0, 0.5, 100)\nstandard_errors = np.abs(np.random.normal(0, 0.1, 100))\n\nfig = cate_line_plot(estimated_cates, true_cates=true_cates, standard_errors=standard_errors, window=5)\nfig"
  },
  {
    "objectID": "04_Reference/make_partially_linear_dataset_simple.html",
    "href": "04_Reference/make_partially_linear_dataset_simple.html",
    "title": "make_partially_linear_dataset_simple",
    "section": "",
    "text": "make_partially_linear_dataset_simple(\n    n_obs=1000,\n    n_confounders=5,\n    dim_heterogeneity=2,\n    binary_treatment=True,\n    seed=None,\n)\nSimulate data generating process from a partially linear model with a simple 1 or 2 dimensional CATE function.\nThe outcome is continuous and the treatment can be binary or continuous. The dataset is generated using the make_heterogeneous_data function from the doubleml package.\nThe general form of the data generating process is, in the case of dim_heterogeneity=1:\n\\[\ny_i= \\\\tau (x_0) d_i + g(\\mathbf{X_i})+\\epsilon_i\n\\] \\[\nd_i=f(\\mathbf{X_i})+\\eta_i\n\\]\nor, in the case of dim_heterogeneity=2:\n\\[\ny_i= \\\\tau (x_0,x_1) d_i + g(\\mathbf{X_i})+\\epsilon_i\n\\] \\[\nd_i=f(\\mathbf{X_i})+\\eta_i\n\\]\nwhere \\(y_i\\) is the outcome, \\(d_i\\) is the treatment, \\(\\mathbf{X_i}\\) are the confounders, \\(\\epsilon_i\\) and \\(\\eta_i\\) are the error terms, \\(\\\\tau\\) is the CATE function, \\(g\\) is the outcome function, and \\(f\\) is the treatment function.\nSee the doubleml documentation for more details on the specific functional forms of the data generating process.\nHere the ATE is defined as the average of the CATE function over all observations: \\(\\mathbb{E}[\\\\tau (\\cdot)]\\)\nAs a DAG, the data generating process can be roughly represented as:"
  },
  {
    "objectID": "04_Reference/make_partially_linear_dataset_simple.html#parameters",
    "href": "04_Reference/make_partially_linear_dataset_simple.html#parameters",
    "title": "make_partially_linear_dataset_simple",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn_obs\nint\nThe number of observations to generate.\n1000\n\n\nn_confounders\nint\nThe number of confounders \\(X\\).\n5\n\n\ndim_heterogeneity\nint\nThe dimension of the heterogeneity \\(x_0\\) or \\((x_0,x_1)\\). Can only be 1 or 2.\n2\n\n\nbinary_treatment\nbool\nWhether the treatment \\(d\\) is binary or continuous.\nTrue\n\n\nseed\nint | None\nThe seed to use for the random number generator.\nNone"
  },
  {
    "objectID": "04_Reference/make_partially_linear_dataset_simple.html#returns",
    "href": "04_Reference/make_partially_linear_dataset_simple.html#returns",
    "title": "make_partially_linear_dataset_simple",
    "section": "Returns",
    "text": "Returns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ndf\npandas.DataFrame\nThe generated dataset where y is the outcome, d is the treatment, and X are the confounders with a 1d or 2d subset utilized for heterogeneity.\n\n\ntrue_cates\nnumpy.ndarray\nThe true conditional average treatment effects.\n\n\ntrue_ate\nfloat\nThe true average treatment effect."
  },
  {
    "objectID": "04_Reference/make_partially_linear_dataset_simple.html#examples",
    "href": "04_Reference/make_partially_linear_dataset_simple.html#examples",
    "title": "make_partially_linear_dataset_simple",
    "section": "Examples",
    "text": "Examples\n\nfrom caml.extensions.synthetic_data import make_partially_linear_dataset_simple\ndf, true_cates, true_ate = make_partially_linear_dataset_simple(n_obs=1000,\n                                                                n_confounders=5,\n                                                                dim_heterogeneity=2,\n                                                                binary_treatment=True,\n                                                                seed=1)\n\nprint(f\"True CATES: {true_cates[:5]}\")\nprint(f\"True ATE: {true_ate}\")\nprint(df.head())\n\nTrue CATES: [5.07318438 4.22638341 4.84246206 5.02852819 7.30906609]\nTrue ATE: 4.434805144050488\n          y    d        X0        X1        X2        X3        X4\n0  5.814804  1.0  0.560647  0.182920  0.938085  0.721671  0.209634\n1  4.593199  1.0  0.113353  0.358469  0.271148  0.908152  0.497946\n2  1.489081  0.0  0.970009  0.981170  0.319852  0.034913  0.003447\n3  6.569753  1.0  0.386105  0.317130  0.339849  0.232991  0.463512\n4  8.249305  1.0  0.733222  0.360575  0.903222  0.600965  0.110013"
  },
  {
    "objectID": "04_Reference/cate_true_vs_estimated_plot.html",
    "href": "04_Reference/cate_true_vs_estimated_plot.html",
    "title": "cate_true_vs_estimated_plot",
    "section": "",
    "text": "cate_true_vs_estimated_plot(\n    true_cates,\n    estimated_cates,\n    *,\n    figure_kwargs={},\n    scatter_kwargs={},\n)\nPlots a scatter plot of the estimated CATEs against the true CATEs."
  },
  {
    "objectID": "04_Reference/cate_true_vs_estimated_plot.html#parameters",
    "href": "04_Reference/cate_true_vs_estimated_plot.html#parameters",
    "title": "cate_true_vs_estimated_plot",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nestimated_cates\nArrayLike\nThe estimated CATEs.\nrequired\n\n\nfigure_kwargs\ndict\nMatplotlib figure arguments.\n{}\n\n\nscatter_kwargs\ndict\nMatplotlib scatter arguments.\n{}"
  },
  {
    "objectID": "04_Reference/cate_true_vs_estimated_plot.html#returns",
    "href": "04_Reference/cate_true_vs_estimated_plot.html#returns",
    "title": "cate_true_vs_estimated_plot",
    "section": "Returns",
    "text": "Returns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nmatplotlib.pyplot.Figure\nThe scatter plot figure object."
  },
  {
    "objectID": "04_Reference/cate_true_vs_estimated_plot.html#examples",
    "href": "04_Reference/cate_true_vs_estimated_plot.html#examples",
    "title": "cate_true_vs_estimated_plot",
    "section": "Examples",
    "text": "Examples\n\nimport numpy as np\nfrom caml.extensions.plots import cate_true_vs_estimated_plot\n\nnp.random.seed(42)\ntrue_cates = np.random.normal(0, 1, 100)\nestimated_cates = true_cates + np.random.normal(0, 0.5, 100)\n\nfig = cate_true_vs_estimated_plot(true_cates, estimated_cates)\nfig"
  },
  {
    "objectID": "04_Reference/logging.configure_logging.html",
    "href": "04_Reference/logging.configure_logging.html",
    "title": "logging.configure_logging",
    "section": "",
    "text": "logging.configure_logging(level=logging.WARNING)\nConfigure logging for the entire application.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlevel\nint\nThe logging level to use. Defaults to WARNING. Can be overridden by environment variable CAML_LOG_LEVEL.\nlogging.WARNING"
  },
  {
    "objectID": "04_Reference/logging.configure_logging.html#parameters",
    "href": "04_Reference/logging.configure_logging.html#parameters",
    "title": "logging.configure_logging",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nlevel\nint\nThe logging level to use. Defaults to WARNING. Can be overridden by environment variable CAML_LOG_LEVEL.\nlogging.WARNING"
  },
  {
    "objectID": "04_Reference/logging.setup_logging.html",
    "href": "04_Reference/logging.setup_logging.html",
    "title": "logging.setup_logging",
    "section": "",
    "text": "logging.setup_logging\nlogging.setup_logging(verbose=1)\nSet up logging configuration.\nThis function configures the logging module with a basic configuration. It sets the logging level to INFO and the log message format to only include the message itself. The logging handler used is rich_handler.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "04_Reference/generics.cls_typechecked.html",
    "href": "04_Reference/generics.cls_typechecked.html",
    "title": "generics.cls_typechecked",
    "section": "",
    "text": "generics.cls_typechecked(cls)\nClass decorator to typecheck all methods of a class.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\n\nThe class to decorate.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncls: The decorated class."
  },
  {
    "objectID": "04_Reference/generics.cls_typechecked.html#parameters",
    "href": "04_Reference/generics.cls_typechecked.html#parameters",
    "title": "generics.cls_typechecked",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ncls\n\nThe class to decorate.\nrequired"
  },
  {
    "objectID": "04_Reference/generics.cls_typechecked.html#returns",
    "href": "04_Reference/generics.cls_typechecked.html#returns",
    "title": "generics.cls_typechecked",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\ncls: The decorated class."
  },
  {
    "objectID": "04_Reference/support_matrix.html",
    "href": "04_Reference/support_matrix.html",
    "title": "Outcome/Treatment Type Support Matrix",
    "section": "",
    "text": "Outcome\nTreatment\nFastOLS\nCamlCATE\n\n\n\n\nContinuous\nBinary\n✅Full\n✅Full\n\n\nContinuous\nContinuous\n✅Full\n🟡Partial1\n\n\nContinuous\nCategorical\n❌Not yet\n✅Full\n\n\nBinary\nBinary\n✅Full\n🟡Partial2\n\n\nBinary\nContinuous\n✅Full\n🟡Partial3\n\n\nBinary\nCategorical\n❌Not yet\n🟡Partial4\n\n\nCategorical\nBinary\n❌Not yet\n❌Not yet\n\n\nCategorical\nContinuous\n❌Not yet\n❌Not yet\n\n\nCategorical\nCategorical\n❌Not yet\n❌Not yet\n\n\nMulti-Dimensional\n-\n✅Full\n❌Not yet\n\n\n-\nMulti-Dimensional\n❌Not yet\n❌Not yet\nIf you have a specific use case that is not covered by the current support matrix, please feel free to open an issue.",
    "crumbs": [
      "Outcome/Treatment Type Support Matrix"
    ]
  },
  {
    "objectID": "04_Reference/support_matrix.html#footnotes",
    "href": "04_Reference/support_matrix.html#footnotes",
    "title": "Outcome/Treatment Type Support Matrix",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nMissing validate method.↩︎\nMissing validate method.↩︎\nMissing validate method.↩︎\nMissing validate method.↩︎",
    "crumbs": [
      "Outcome/Treatment Type Support Matrix"
    ]
  },
  {
    "objectID": "04_Reference/FastOLS.html",
    "href": "04_Reference/FastOLS.html",
    "title": "FastOLS",
    "section": "",
    "text": "FastOLS(\n    self,\n    Y,\n    T,\n    G=None,\n    X=None,\n    W=None,\n    *,\n    discrete_treatment=False,\n    engine='cpu',\n)\nFastOLS is an optimized implementation of the OLS estimator designed specifically with treatment effect estimation in mind.\nFastOLS is experimental and may change significantly in future versions.\nThis class estimates a standard linear regression model for any number of continuous or binary outcomes and a single continuous or binary treatment, and provides estimates for the Average Treatment Effects (ATEs) and Group Average Treatment Effects (GATEs) out of the box. Additionally, methods are provided for estimating custom GATEs & Conditional Average Treatment Effects (CATEs) of individual observations, which can also be used for out-of-sample predictions. Note, this method assumes linear treatment effects and heterogeneity, which is typically sufficient when primarily concerned with ATEs and GATEs.\nThis class leverages JAX for fast numerical computations, which can be installed using pip install caml[jax], defaulting to NumPy if JAX is not available. For GPU acceleration, install JAX with GPU support using pip install caml[jax-gpu].\nFor outcome/treatment support, see Support Matrix.\nFor model specification details, see Model Specifications."
  },
  {
    "objectID": "04_Reference/FastOLS.html#parameters",
    "href": "04_Reference/FastOLS.html#parameters",
    "title": "FastOLS",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nY\nCollection[str]\nA list of outcome variable names.\nrequired\n\n\nT\nstr\nThe treatment variable name.\nrequired\n\n\nG\nCollection[str] | None\nA list of group variable names. These will be the groups for which GATEs will be estimated.\nNone\n\n\nX\nCollection[str] | None\nA list of covariate variable names. These will be the covariates for which heterogeneity/CATEs can be estimated.\nNone\n\n\nW\nCollection[str] | None\nA list of additional covariate variable names to be used as controls. These will be the additional covariates not used for modeling heterogeneity/CATEs.\nNone\n\n\ndiscrete_treatment\nbool\nWhether the treatment is discrete\nFalse\n\n\nengine\nstr\nThe engine to use for computation. Can be “cpu” or “gpu”. Note “gpu” requires JAX to be installed, which can be installed via pip install caml[jax-gpu].\n'cpu'"
  },
  {
    "objectID": "04_Reference/FastOLS.html#attributes",
    "href": "04_Reference/FastOLS.html#attributes",
    "title": "FastOLS",
    "section": "Attributes",
    "text": "Attributes\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nY\nCollection[str]\nA list of outcome variable names.\n\n\nT\nstr\nThe treatment variable name.\n\n\nG\nCollection[str] | None\nThe list of group variable names. These will be the groups for which GATEs will be estimated.\n\n\nX\nCollection[str] | None\nThe list of variable names representing the confounder/control feature set to be utilized for estimating heterogeneity/CATEs, that are in addition to G.\n\n\nW\nCollection[str] | None\nThe list of variable names representing the confounder/control feature not utilized for estimating heterogeneity/CATEs.\n\n\ndiscrete_treatment\nbool\nWhether the treatment is binary.\n\n\nengine\nstr\nThe engine to use for computation. Can be “cpu” or “gpu”. Note “gpu” requires JAX to be installed, which can be installed via pip install caml[jax-gpu]\n\n\nformula\nstr\nThe formula leveraged for design matrix creation via Patsy.\n\n\nresults\ndict\nA dictionary containing the results of the fitted model & estimated ATEs/GATEs."
  },
  {
    "objectID": "04_Reference/FastOLS.html#methods",
    "href": "04_Reference/FastOLS.html#methods",
    "title": "FastOLS",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nfit\nFits the regression model on the provided data and, optionally, estimates Average Treatment Effect(s) (ATE) and Group Average Treatment Effect(s) (GATE).\n\n\nestimate_ate\nEstimate Average Treatment Effects (ATEs) of T on each Y from fitted model.\n\n\nestimate_cate\nEstimate Conditional Average Treatment Effects (CATEs) for all given observations.\n\n\npredict\nAlias for estimate_cate.\n\n\nprettify_treatment_effects\nConvert treatment effects dictionary to a pandas DataFrame.\n\n\n\n\nfit\nFastOLS.fit(df, *, n_jobs=-1, estimate_effects=True, robust_vcv=False)\nFits the regression model on the provided data and, optionally, estimates Average Treatment Effect(s) (ATE) and Group Average Treatment Effect(s) (GATE).\nIf estimate_effects is True, the method estimates Average Treatment Effects (ATEs) and Group Average Treatment Effects (GATEs), based on specified G. This leverages estimate_ate method under the hood, but efficiently reuses the data and parallelizes the computation of GATEs.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndf\nPandasConvertibleDataFrame\nInput dataframe to fit the model on. Supported formats: pandas DataFrame, PySpark DataFrame, Polars DataFrame, or Any object with toPandas() or to_pandas() method\nrequired\n\n\nn_jobs\nint\nThe number of jobs to use for parallel processing in the estimation of GATEs. Defaults to -1, which uses all available processors. If getting OOM errors, try setting n_jobs to a lower value.\n-1\n\n\nestimate_effects\nbool\nWhether to estimate Average Treatment Effects (ATEs) and Group Average Treatment Effects (GATEs).\nTrue\n\n\nrobust_vcv\nbool\nWhether to use heteroskedasticity-robust (white) variance-covariance matrix and standard errors.\nFalse\n\n\n\n\n\nExamples\n\nfo_obj.fit(df, n_jobs=4, estimate_effects=True, robust_vcv=True)\n\nfo_obj.results.keys()\n\ndict_keys(['params', 'vcv', 'std_err', 'treatment_effects'])\n\n\n\n\n\nestimate_ate\nFastOLS.estimate_ate(\n    df,\n    *,\n    return_results_dict=False,\n    group='Custom Group',\n    membership=None,\n    _diff_matrix=None,\n)\nEstimate Average Treatment Effects (ATEs) of T on each Y from fitted model.\nIf the entire dataframe is provided, the function will estimate the ATE of the entire population. If a subset of the dataframe is provided, the function will estimate the ATE of the subset (e.g., GATEs).\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndf\nPandasConvertibleDataFrame\nDataframe containing the data to estimate the ATEs. Supported formats: pandas DataFrame, PySpark DataFrame, Polars DataFrame, or Any object with toPandas() or to_pandas() method\nrequired\n\n\nreturn_results_dict\nbool\nIf True, the function returns a dictionary containing ATEs/GATEs, standard errors, t-statistics, confidence intervals, and p-values. If False, the function returns a numpy array containing ATEs/GATEs alone.\nFalse\n\n\ngroup\nstr\nName of the group to estimate the ATEs for.\n'Custom Group'\n\n\nmembership\nstr | None\nName of the membership variable to estimate the ATEs for.\nNone\n\n\n_diff_matrix\njnp.ndarray | None = None\nPrivate argument used in fit method.\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\njnp.ndarray | dict\nEstimated ATEs/GATEs or dictionary containing the estimated ATEs/GATEs and their standard errors, t-statistics, and p-values.\n\n\n\n\n\nExamples\n\ndf_filtered = df.query(\n    \"X3_binary == 0 & X1_continuous &lt; 5\"\n).copy()\n\ncustom_gate = fo_obj.estimate_ate(df_filtered)\n\ncustom_gate\n\nArray([[-8.91602003, -0.18047711]], dtype=float64)\n\n\n\ncustom_gate = fo_obj.estimate_ate(df_filtered, return_results_dict=True, group=\"My Custom Group\")\n\ncustom_gate\n\n{'My Custom Group': {'outcome': ['Y1_continuous', 'Y2_binary'],\n  'ate': Array([[-8.91602003, -0.18047711]], dtype=float64),\n  'std_err': Array([[0.04806431, 0.01503391]], dtype=float64),\n  't_stat': Array([[-185.50188761,  -12.00467035]], dtype=float64),\n  'pval': Array([[0., 0.]], dtype=float64),\n  'n': 2799,\n  'n_treated': 550,\n  'n_control': 2249}}\n\n\n\n\n\nestimate_cate\nFastOLS.estimate_cate(df, *, return_results_dict=False)\nEstimate Conditional Average Treatment Effects (CATEs) for all given observations.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndf\nPandasConvertibleDataFrame\nDataframe containing the data to estimate CATEs for. Supported formats: pandas DataFrame, PySpark DataFrame, Polars DataFrame, or Any object with toPandas() or to_pandas() method\nrequired\n\n\nreturn_results_dict\nbool\nIf True, the function returns a dictionary containing CATEs, standard errors, t-statistics, confidence intervals, and p-values. If False, the function returns a numpy array containing CATEs alone.\nFalse\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\njnp.ndarray | dict\nCATEs or dictionary containing CATEs, standard errors, t-statistics, and p-values.\n\n\n\n\n\nExamples\n\ncates = fo_obj.estimate_cate(df)\ncates[:5]\n\nArray([[ -0.33752601,  -0.44186948],\n       [-15.6089809 ,   0.04650733],\n       [ -3.49377716,  -0.39518117],\n       [ -3.3922687 ,  -0.33774498],\n       [  1.46430083,  -0.53608081]], dtype=float64)\n\n\n\nres = fo_obj.estimate_cate(df, return_results_dict=True)\nres.keys()\n\ndict_keys(['outcome', 'cate', 'std_err', 't_stat', 'pval'])\n\n\n\n\n\npredict\nFastOLS.predict(df, *, return_results_dict=False)\nAlias for estimate_cate.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndf\nPandasConvertibleDataFrame\nDataframe containing the data to estimate CATEs for. Supported formats: pandas DataFrame, PySpark DataFrame, Polars DataFrame, or Any object with toPandas() or to_pandas() method\nrequired\n\n\nreturn_results_dict\nbool\nIf True, the function returns a dictionary containing CATEs, standard errors, t-statistics, confidence intervals, and p-values. If False, the function returns a numpy array containing CATEs alone.\nFalse\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\njnp.ndarray | dict\nCATEs or dictionary containing CATEs, standard errors, t-statistics, and p-values.\n\n\n\n\n\nExamples\n\ncates = fo_obj.predict(df)\ncates[:5]\n\nArray([[ -0.33752601,  -0.44186948],\n       [-15.6089809 ,   0.04650733],\n       [ -3.49377716,  -0.39518117],\n       [ -3.3922687 ,  -0.33774498],\n       [  1.46430083,  -0.53608081]], dtype=float64)\n\n\n\nres = fo_obj.predict(df, return_results_dict=True)\nres.keys()\n\ndict_keys(['outcome', 'cate', 'std_err', 't_stat', 'pval'])\n\n\n\n\n\nprettify_treatment_effects\nFastOLS.prettify_treatment_effects(effects=None)\nConvert treatment effects dictionary to a pandas DataFrame.\nIf no argument is provided, the results are constructed from internal results dictionary. This is useful default behavior. For custom treatment effects, you can pass the results generated by the estimate_ate method.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\neffects\ndict\nDictionary of treatment effects. If None, the results are constructed from internal results dictionary.\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nDataFrame of treatment effects.\n\n\n\n\n\nExamples\n\nfo_obj.prettify_treatment_effects()\n\n\n\n\n\n\n\n\ngroup\nmembership\noutcome\nate\nstd_err\nt_stat\npval\nn\nn_treated\nn_control\n\n\n\n\n0\noverall\nNone\nY1_continuous\n-6.957200\n0.029998\n-231.920818\n0.0\n10000\n1930\n8070\n\n\n1\noverall\nNone\nY2_binary\n-0.263884\n0.010121\n-26.071914\n0.0\n10000\n1930\n8070\n\n\n2\nX3_binary\n1\nY1_continuous\n-7.080507\n0.034477\n-205.368502\n0.0\n6708\n1282\n5426\n\n\n3\nX3_binary\n1\nY2_binary\n-0.273672\n0.011772\n-23.247301\n0.0\n6708\n1282\n5426\n\n\n4\nX3_binary\n0\nY1_continuous\n-6.705941\n0.047486\n-141.217991\n0.0\n3292\n648\n2644\n\n\n5\nX3_binary\n0\nY2_binary\n-0.243940\n0.015095\n-16.160795\n0.0\n3292\n648\n2644\n\n\n6\nX4_binary\n1\nY1_continuous\n-6.924531\n0.039610\n-174.817862\n0.0\n4570\n892\n3678\n\n\n7\nX4_binary\n1\nY2_binary\n-0.249593\n0.013495\n-18.495370\n0.0\n4570\n892\n3678\n\n\n8\nX4_binary\n0\nY1_continuous\n-6.984695\n0.038631\n-180.805862\n0.0\n5430\n1038\n4392\n\n\n9\nX4_binary\n0\nY2_binary\n-0.275912\n0.012617\n-21.869035\n0.0\n5430\n1038\n4392\n\n\n\n\n\n\n\n\n## Using a custom GATE\ncustom_gate = fo_obj.estimate_ate(df_filtered, return_results_dict=True, group=\"My Custom Group\")\nfo_obj.prettify_treatment_effects(custom_gate)\n\n\n\n\n\n\n\n\ngroup\nmembership\noutcome\nate\nstd_err\nt_stat\npval\nn\nn_treated\nn_control\n\n\n\n\n0\nMy Custom Group\nNone\nY1_continuous\n-8.916020\n0.048064\n-185.501888\n0.0\n2799\n550\n2249\n\n\n1\nMy Custom Group\nNone\nY2_binary\n-0.180477\n0.015034\n-12.004670\n0.0\n2799\n550\n2249"
  },
  {
    "objectID": "04_Reference/FastOLS.html#model-specification",
    "href": "04_Reference/FastOLS.html#model-specification",
    "title": "FastOLS",
    "section": "",
    "text": "The model is given by: \\[\n\\begin{equation}\n\\mathbf{Y} = T \\beta + \\mathbf{Q}\\mathbf{\\Gamma} + \\left(T \\circ \\mathbf{Q}\\right)\\mathbf{\\Omega} + \\mathbf{W}\\mathbf{\\Psi} + \\mathbf{E}\n\\tag{1}\n\\end{equation}\n\\]\nwhere \\(\\mathbf{Y}_{n \\times p}\\) is the matrix of \\(p\\) outcomes, \\(T_{n \\times 1}\\) is the treatment variable, \\(\\mathbf{Q}_{n \\times (j+l)} = \\bigl[\\mathbf{X} \\; \\mathbf{G} \\bigr]\\) is the horizontal stack matrix of \\(j\\) covariates and \\(l\\) group variables, \\(\\mathbf{W}_{n \\times m}\\) is the matrix of \\(m\\) control covariates, \\(\\beta_{1 \\times p}\\) is the vector of coefficients on \\(T\\), \\(\\mathbf{\\Gamma}_{(j+l) \\times p}\\) is the matrix of coefficients on \\(\\mathbf{Q}\\), \\(\\mathbf{\\Omega}_{(j+l) \\times p}\\) is the matrix of coefficients on the interaction terms between \\(T\\) and \\(\\mathbf{Q}\\), \\(\\mathbf{\\Psi}_{m \\times p}\\) is the matrix of coefficients on \\(\\mathbf{W}\\), and \\(\\mathbf{E}_{n \\times p}\\) is the error term matrix.\n\\(\\mathbf{Q}\\) contains the covariates and group variables used to model treatment effect heterogeneity via interaction terms.\n\n\nOur average treatment effect (ATE) \\(\\tau\\) for a binary treatment variable \\(T\\) is defined as:\n\\[\n\\tau = \\mathbb{E}_n\\left[\\mathbb{E}\\left[\\mathbf{Y} \\mid T = 1\\right] - \\mathbb{E}\\left[\\mathbf{Y} \\mid T = 0\\right]\\right]\n\\]\nLet \\(D\\) denote the design matrix for (1), then assuming exogeneity in \\(T\\), the ATEs are identified and can be estimated as follows: \\[\n\\mathbf{\\tau} = \\mathbf{\\Theta'}\\bar{d}\n\\]\nwhere \\(\\mathbf{\\Theta'} = \\left[\\beta' \\; \\mathbf{\\Gamma'} \\; \\mathbf{\\Omega'} \\; \\mathbf{\\Psi'}\\right]\\) is the horizontally concatenated matrix of transposed coefficient matrices, and \\(\\bar{d} = \\mathbb{E}_n\\left[D_{T=1} - D_{T=0}\\right]\\) is the the average difference in the design matrix from toggling the treatment variable across all observations.\nFurthermore, for each outcome \\(k \\in \\{1,2,...,p\\}\\), we can estimate the standard error of the ATE as follows: \\[\n\\text{SE}(\\tau_k) = \\sqrt{\\bar{d}'\\text{VCV}(\\mathbf{\\Theta}_k)\\bar{d}}\n\\]\nwhere \\(\\text{VCV}(\\mathbf{\\Theta}_k)\\) is the variance-covariance matrix of the estimated coefficients for the \\(k\\)-th outcome.\nThis logic extends naturally to the estimation of GATEs and CATEs, where \\(\\bar{d} = \\mathbb{E}_n\\left[D_{T=1} - D_{T=0} | \\mathbf{G}=g\\right]\\) \\(\\bar{d} = \\mathbb{E}_n\\left[D_{T=1} - D_{T=0} | \\mathbf{G}=g, \\mathbf{X}=x\\right]\\), \\(\\dots\\), etc. and to continuous treatments \\(\\bar{d} = \\mathbb{E}_n\\left[D_{T=t+1} - D_{T=t}\\right]\\), \\(\\dots\\), etc."
  },
  {
    "objectID": "04_Reference/FastOLS.html#this-logic-naturally-extends-to-the-estimation-of-gates-and-cates-where-bard-mathbbe_nleftd_t1---d_t0-gright",
    "href": "04_Reference/FastOLS.html#this-logic-naturally-extends-to-the-estimation-of-gates-and-cates-where-bard-mathbbe_nleftd_t1---d_t0-gright",
    "title": "FastOLS",
    "section": "",
    "text": "Y : Collection[str] A list of outcome variable names. T : str The treatment variable name. G : Collection[str] | None A list of group variable names, by default None. These will be the groups for which GATEs will be estimated. X : Collection[str] | None A list of covariate variable names, by default None. These will be the covariates for which heterogeneity/CATEs can be estimated. W : Collection[str] | None A list of additional covariate variable names to be used as controls, by default None. These will be the additional covariates not used for modeling heterogeneity/CATEs. discrete_treatment : bool Whether the treatment is discrete, by default False engine : str The engine to use for computation, by default “cpu”. Can be “cpu” or “gpu”. Note “gpu” requires JAX to be installed, which can be installed via pip install caml[jax-gpu]."
  },
  {
    "objectID": "02_Concepts/models.html",
    "href": "02_Concepts/models.html",
    "title": "Model Specifications",
    "section": "",
    "text": "The model is given by: \\[\n\\begin{equation}\n\\mathbf{Y} = T \\beta + \\mathbf{Q}\\mathbf{\\Gamma} + \\left(T \\circ \\mathbf{Q}\\right)\\mathbf{\\Omega} + \\mathbf{W}\\mathbf{\\Psi} + \\mathbf{E}\n\\tag{1}\n\\end{equation}\n\\]\nwhere\n\n\\(\\mathbf{Y}_{n \\times p}\\) is the matrix of \\(p\\) outcomes\n\\(T_{n \\times 1}\\) is the treatment variable\n\\(\\mathbf{Q}_{n \\times (j+l)} = \\bigl[\\mathbf{X} \\; \\mathbf{G} \\bigr]\\) is the horizontal stack matrix of \\(j\\) covariates and \\(l\\) group variables\n\\(\\mathbf{W}_{n \\times m}\\) is the matrix of \\(m\\) control covariates\n\\(\\beta_{1 \\times p}\\) is the vector of coefficients on \\(T\\)\n\\(\\mathbf{\\Gamma}_{(j+l) \\times p}\\) is the matrix of coefficients on \\(\\mathbf{Q}\\)\n\\(\\mathbf{\\Omega}_{(j+l) \\times p}\\) is the matrix of coefficients on the interaction terms between \\(T\\) and \\(\\mathbf{Q}\\)\n\\(\\mathbf{\\Psi}_{m \\times p}\\) is the matrix of coefficients on \\(\\mathbf{W}\\)\n\\(\\mathbf{E}_{n \\times p}\\) is the error term matrix\n\n\\(\\mathbf{Q}\\) contains the covariates and group variables used to model treatment effect heterogeneity via interaction terms.\n\n\n\nOur average treatment effects (ATE) \\(\\tau\\) for a binary treatment variable \\(T\\) is defined as:\n\\[\n\\tau = \\mathbb{E}_n[\\mathbf{Y}_1 - \\mathbf{Y}_0]\n\\]\nwhere \\(\\mathbf{Y}_1\\) and \\(\\mathbf{Y}_0\\) are the potential outcomes. Assuming exogeneity in \\(T\\), the ATEs are identified and can be estimated as follows:\n\\[\n\\tau = \\mathbb{E}_n\\left[\\mathbb{E}\\left[\\mathbf{Y} \\mid T = 1\\right] - \\mathbb{E}\\left[\\mathbf{Y} \\mid T = 0\\right]\\right]\n\\]\nWithin the context of (1), this can be estimated via:\n\\[\n\\mathbf{\\tau} = \\mathbf{\\Theta'}\\bar{d}\n\\]\nwhere \\(\\mathbf{\\Theta'} = \\left[\\beta' \\; \\mathbf{\\Gamma'} \\; \\mathbf{\\Omega'} \\; \\mathbf{\\Psi'}\\right]\\) is the horizontally concatenated matrix of transposed coefficient matrices, and \\(\\bar{d} = \\mathbb{E}_n\\left[D_{T=1} - D_{T=0}\\right]\\) is the the average difference in the design matrix \\(D\\) of (1) from toggling the treatment variable across all observations.\nFurthermore, for each outcome \\(k \\in \\{1,2,...,p\\}\\), we can estimate the standard error of the ATE as follows: \\[\n\\text{SE}(\\tau_k) = \\sqrt{\\bar{d}'\\text{VCV}(\\mathbf{\\Theta}_k)\\bar{d}}\n\\]\nwhere \\(\\text{VCV}(\\mathbf{\\Theta}_k)\\) is the variance-covariance matrix of the estimated coefficients for the \\(k\\)-th outcome.\nThis logic extends naturally to the estimation of GATEs and CATEs (e.g., \\(\\bar{d} = \\mathbb{E}_n\\left[D_{T=1} - D_{T=0} | \\mathbf{G}=g\\right]\\), \\(\\bar{d} = \\mathbb{E}_n\\left[D_{T=1} - D_{T=0} | \\mathbf{G}=g, \\mathbf{X}=x\\right]\\), \\(\\dots\\), etc.) and to continuous treatments (e.g., \\(\\bar{d} = \\mathbb{E}_n\\left[D_{T=t+1} - D_{T=t}\\right]\\), \\(\\dots\\), etc.).",
    "crumbs": [
      "Model Specifications"
    ]
  },
  {
    "objectID": "02_Concepts/models.html#fastols",
    "href": "02_Concepts/models.html#fastols",
    "title": "Model Specifications",
    "section": "",
    "text": "The model is given by: \\[\n\\begin{equation}\n\\mathbf{Y} = T \\beta + \\mathbf{Q}\\mathbf{\\Gamma} + \\left(T \\circ \\mathbf{Q}\\right)\\mathbf{\\Omega} + \\mathbf{W}\\mathbf{\\Psi} + \\mathbf{E}\n\\tag{1}\n\\end{equation}\n\\]\nwhere\n\n\\(\\mathbf{Y}_{n \\times p}\\) is the matrix of \\(p\\) outcomes\n\\(T_{n \\times 1}\\) is the treatment variable\n\\(\\mathbf{Q}_{n \\times (j+l)} = \\bigl[\\mathbf{X} \\; \\mathbf{G} \\bigr]\\) is the horizontal stack matrix of \\(j\\) covariates and \\(l\\) group variables\n\\(\\mathbf{W}_{n \\times m}\\) is the matrix of \\(m\\) control covariates\n\\(\\beta_{1 \\times p}\\) is the vector of coefficients on \\(T\\)\n\\(\\mathbf{\\Gamma}_{(j+l) \\times p}\\) is the matrix of coefficients on \\(\\mathbf{Q}\\)\n\\(\\mathbf{\\Omega}_{(j+l) \\times p}\\) is the matrix of coefficients on the interaction terms between \\(T\\) and \\(\\mathbf{Q}\\)\n\\(\\mathbf{\\Psi}_{m \\times p}\\) is the matrix of coefficients on \\(\\mathbf{W}\\)\n\\(\\mathbf{E}_{n \\times p}\\) is the error term matrix\n\n\\(\\mathbf{Q}\\) contains the covariates and group variables used to model treatment effect heterogeneity via interaction terms.\n\n\n\nOur average treatment effects (ATE) \\(\\tau\\) for a binary treatment variable \\(T\\) is defined as:\n\\[\n\\tau = \\mathbb{E}_n[\\mathbf{Y}_1 - \\mathbf{Y}_0]\n\\]\nwhere \\(\\mathbf{Y}_1\\) and \\(\\mathbf{Y}_0\\) are the potential outcomes. Assuming exogeneity in \\(T\\), the ATEs are identified and can be estimated as follows:\n\\[\n\\tau = \\mathbb{E}_n\\left[\\mathbb{E}\\left[\\mathbf{Y} \\mid T = 1\\right] - \\mathbb{E}\\left[\\mathbf{Y} \\mid T = 0\\right]\\right]\n\\]\nWithin the context of (1), this can be estimated via:\n\\[\n\\mathbf{\\tau} = \\mathbf{\\Theta'}\\bar{d}\n\\]\nwhere \\(\\mathbf{\\Theta'} = \\left[\\beta' \\; \\mathbf{\\Gamma'} \\; \\mathbf{\\Omega'} \\; \\mathbf{\\Psi'}\\right]\\) is the horizontally concatenated matrix of transposed coefficient matrices, and \\(\\bar{d} = \\mathbb{E}_n\\left[D_{T=1} - D_{T=0}\\right]\\) is the the average difference in the design matrix \\(D\\) of (1) from toggling the treatment variable across all observations.\nFurthermore, for each outcome \\(k \\in \\{1,2,...,p\\}\\), we can estimate the standard error of the ATE as follows: \\[\n\\text{SE}(\\tau_k) = \\sqrt{\\bar{d}'\\text{VCV}(\\mathbf{\\Theta}_k)\\bar{d}}\n\\]\nwhere \\(\\text{VCV}(\\mathbf{\\Theta}_k)\\) is the variance-covariance matrix of the estimated coefficients for the \\(k\\)-th outcome.\nThis logic extends naturally to the estimation of GATEs and CATEs (e.g., \\(\\bar{d} = \\mathbb{E}_n\\left[D_{T=1} - D_{T=0} | \\mathbf{G}=g\\right]\\), \\(\\bar{d} = \\mathbb{E}_n\\left[D_{T=1} - D_{T=0} | \\mathbf{G}=g, \\mathbf{X}=x\\right]\\), \\(\\dots\\), etc.) and to continuous treatments (e.g., \\(\\bar{d} = \\mathbb{E}_n\\left[D_{T=t+1} - D_{T=t}\\right]\\), \\(\\dots\\), etc.).",
    "crumbs": [
      "Model Specifications"
    ]
  },
  {
    "objectID": "02_Concepts/models.html#model-specification",
    "href": "02_Concepts/models.html#model-specification",
    "title": "Model Specifications",
    "section": "Model Specification",
    "text": "Model Specification\nThe model is given by: \\[\n\\begin{equation}\n\\mathbf{Y} = T \\beta + \\mathbf{Q}\\mathbf{\\Gamma} + \\left(T \\circ \\mathbf{Q}\\right)\\mathbf{\\Omega} + \\mathbf{W}\\mathbf{\\Psi} + \\mathbf{E}\n\\tag{1}\n\\end{equation}\n\\]\nwhere \\(\\mathbf{Y}_{n \\times p}\\) is the matrix of \\(p\\) outcomes, \\(T_{n \\times 1}\\) is the treatment variable, \\(\\mathbf{Q}_{n \\times (j+l)} = \\bigl[\\mathbf{X} \\; \\mathbf{G} \\bigr]\\) is the horizontal stack matrix of \\(j\\) covariates and \\(l\\) group variables, \\(\\mathbf{W}_{n \\times m}\\) is the matrix of \\(m\\) control covariates, \\(\\beta_{1 \\times p}\\) is the vector of coefficients on \\(T\\), \\(\\mathbf{\\Gamma}_{(j+l) \\times p}\\) is the matrix of coefficients on \\(\\mathbf{Q}\\), \\(\\mathbf{\\Omega}_{(j+l) \\times p}\\) is the matrix of coefficients on the interaction terms between \\(T\\) and \\(\\mathbf{Q}\\), \\(\\mathbf{\\Psi}_{m \\times p}\\) is the matrix of coefficients on \\(\\mathbf{W}\\), and \\(\\mathbf{E}_{n \\times p}\\) is the error term matrix.\n\\(\\mathbf{Q}\\) contains the covariates and group variables used to model treatment effect heterogeneity via interaction terms.\n\nTreatment Effect Estimation & Inference\nOur average treatment effect (ATE) \\(\\tau\\) for a binary treatment variable \\(T\\) is defined as:\n\\[\n\\tau = \\mathbb{E}_n\\left[\\mathbb{E}\\left[\\mathbf{Y} \\mid T = 1\\right] - \\mathbb{E}\\left[\\mathbf{Y} \\mid T = 0\\right]\\right]\n\\]\nLet \\(D\\) denote the design matrix for (1), then assuming exogeneity in \\(T\\), the ATEs are identified and can be estimated as follows: \\[\n\\mathbf{\\tau} = \\mathbf{\\Theta'}\\bar{d}\n\\]\nwhere \\(\\mathbf{\\Theta'} = \\left[\\beta' \\; \\mathbf{\\Gamma'} \\; \\mathbf{\\Omega'} \\; \\mathbf{\\Psi'}\\right]\\) is the horizontally concatenated matrix of transposed coefficient matrices, and \\(\\bar{d} = \\mathbb{E}_n\\left[D_{T=1} - D_{T=0}\\right]\\) is the the average difference in the design matrix from toggling the treatment variable across all observations.\nFurthermore, for each outcome \\(k \\in \\{1,2,...,p\\}\\), we can estimate the standard error of the ATE as follows: \\[\n\\text{SE}(\\tau_k) = \\sqrt{\\bar{d}'\\text{VCV}(\\mathbf{\\Theta}_k)\\bar{d}}\n\\]\nwhere \\(\\text{VCV}(\\mathbf{\\Theta}_k)\\) is the variance-covariance matrix of the estimated coefficients for the \\(k\\)-th outcome.\nThis logic extends naturally to the estimation of GATEs and CATEs, where \\(\\bar{d} = \\mathbb{E}_n\\left[D_{T=1} - D_{T=0} | \\mathbf{G}=g\\right]\\) \\(\\bar{d} = \\mathbb{E}_n\\left[D_{T=1} - D_{T=0} | \\mathbf{G}=g, \\mathbf{X}=x\\right]\\), \\(\\dots\\), etc. and to continuous treatments \\(\\bar{d} = \\mathbb{E}_n\\left[D_{T=t+1} - D_{T=t}\\right]\\), \\(\\dots\\), etc.",
    "crumbs": [
      "Model Specifications"
    ]
  },
  {
    "objectID": "04_Reference/FastOLS.html#examples",
    "href": "04_Reference/FastOLS.html#examples",
    "title": "FastOLS",
    "section": "Examples",
    "text": "Examples\n\nfrom caml import FastOLS\nfrom caml.extensions.synthetic_data import CamlSyntheticDataGenerator\n\ndata_generator = CamlSyntheticDataGenerator(n_cont_outcomes=1,\n                                            n_binary_outcomes=1,\n                                            n_binary_modifiers=2,\n                                            seed=10)\ndf = data_generator.df\n\nfo_obj = FastOLS(\n    Y=[c for c in df.columns if \"Y\" in c],\n    T=\"T1_binary\",\n    G=[c for c in df.columns if \"X\" in c and (\"bin\" in c or \"dis\" in c)],\n    X=[c for c in df.columns if \"X\" in c and \"cont\" in c],\n    W=[c for c in df.columns if \"W\" in c],\n    engine=\"cpu\",\n    discrete_treatment=True,\n)\n\nprint(fo_obj)\n\n================== FastOLS Object ==================\nEngine: cpu\nOutcome Variable: ['Y1_continuous', 'Y2_binary']\nTreatment Variable: T1_binary\nDiscrete Treatment: True\nGroup Variables: ['X3_binary', 'X4_binary']\nFeatures/Confounders for Heterogeneity (X): ['X1_continuous', 'X2_continuous']\nFeatures/Confounders as Controls (W): ['W1_continuous', 'W2_continuous']\nFormula: Y1_continuous + Y2_binary ~ C(T1_binary) + C(X3_binary)*C(T1_binary) + C(X4_binary)*C(T1_binary) + X1_continuous*C(T1_binary) + X2_continuous*C(T1_binary) + W1_continuous + W2_continuous"
  },
  {
    "objectID": "04_Reference/generics.maybe_jit.html",
    "href": "04_Reference/generics.maybe_jit.html",
    "title": "generics.maybe_jit",
    "section": "",
    "text": "generics.maybe_jit(func=None, **jit_kwargs)\nDecorator to JIT compile a function using JAX, if available.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfunc\nCallable | None\nThe function to be JIT compiled.\nNone\n\n\njit_kwargs\ndict\nKeyword arguments to be passed to jax.jit.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nCallable\nThe decorated function or method"
  },
  {
    "objectID": "04_Reference/generics.maybe_jit.html#parameters",
    "href": "04_Reference/generics.maybe_jit.html#parameters",
    "title": "generics.maybe_jit",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nfunc\nCallable | None\nThe function to be JIT compiled.\nNone\n\n\njit_kwargs\ndict\nKeyword arguments to be passed to jax.jit.\n{}"
  },
  {
    "objectID": "04_Reference/generics.maybe_jit.html#returns",
    "href": "04_Reference/generics.maybe_jit.html#returns",
    "title": "generics.maybe_jit",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nCallable\nThe decorated function or method"
  },
  {
    "objectID": "04_Reference/generics.PandasConvertibleDataFrame.html",
    "href": "04_Reference/generics.PandasConvertibleDataFrame.html",
    "title": "generics.PandasConvertibleDataFrame",
    "section": "",
    "text": "generics.PandasConvertibleDataFrame\ngenerics.PandasConvertibleDataFrame()\nProtocol for DataFrame-like objects that are either pandas dataframes or can be converted to pandas via to_pandas() or toPandas() methods.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "04_Reference/generics.PandasConvertibleViaToPandas.html",
    "href": "04_Reference/generics.PandasConvertibleViaToPandas.html",
    "title": "generics.PandasConvertibleViaToPandas",
    "section": "",
    "text": "generics.PandasConvertibleViaToPandas\ngenerics.PandasConvertibleViaToPandas()\nProtocol for DataFrame-like objects that can be converted to pandas via toPandas().\n\n\n\n\n Back to top"
  },
  {
    "objectID": "04_Reference/generics.PandasConvertibleViaToPandas_.html",
    "href": "04_Reference/generics.PandasConvertibleViaToPandas_.html",
    "title": "generics.PandasConvertibleViaToPandas_",
    "section": "",
    "text": "generics.PandasConvertibleViaToPandas_\ngenerics.PandasConvertibleViaToPandas_()\nProtocol for DataFrame-like objects that can be converted to pandas via to_pandas().\n\n\n\n\n Back to top"
  }
]